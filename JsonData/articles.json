[
{ "_id" : { "$oid" : "61d497e845c4f24b6c57516d" }, "title" : "Yazılım Yaşam Döngü Modelleri", "description" : "Yazılım yaşam döngüsü, yazılım endüstrisi tarafından yüksek kaliteli yazılımları müşterinin gereksinimleri doğrultusunda tasarlamak, geliştirmek ve test etmek için kullanılan bir dizi aşamalardan oluşan bir süreçtir. ", "content" : "<h2><strong>Yazılım Yaşam Döngüsü (SDLC) Nedir?</strong></h2><p>Yazılım yaşam döngüsü, yazılım endüstrisi tarafından yüksek kaliteli yazılımları müşterinin gereksinimleri doğrultusunda tasarlamak, geliştirmek ve test etmek için kullanılan bir dizi aşamalardan oluşan bir süreçtir. Yazılım yaşam döngüsünün temel amacı, verilen bütçe ve zaman dahilinde, tüm aşamalarda müşterilerin gereksinimlerini karşılayacak yüksek kaliteli ürünün planlı ve etkili şekilde üretilmesini sağlamaktır.</p><h2><strong>Yazılım Yaşam Döngüsünün Temel Aşamaları Nelerdir?</strong></h2><p>Yazılım yaşam döngüsünün 7 temel aşaması vardır ve her biri yazılım geliştirme sürecinde önemli bir rol oynar.</p><figure class=\"image\"><img src=\"https://miro.medium.com/max/700/1*QMJVoutxWTpR_RZFbtrBHw.jpeg\" alt=\"\" srcset=\"https://miro.medium.com/max/276/1*QMJVoutxWTpR_RZFbtrBHw.jpeg 276w, https://miro.medium.com/max/552/1*QMJVoutxWTpR_RZFbtrBHw.jpeg 552w, https://miro.medium.com/max/640/1*QMJVoutxWTpR_RZFbtrBHw.jpeg 640w, https://miro.medium.com/max/700/1*QMJVoutxWTpR_RZFbtrBHw.jpeg 700w\" sizes=\"100vw\" width=\"700\"></figure><p><strong>1-Planlama</strong></p><p>Planlama, yazılım yaşam döngü sürecinin en önemli aşamalarından biridir. Proje için kapsamlı bir eylem planı belirlemek için gereksinimler ve temel ihtiyaçlar doğrultusunda tüm yazılım yaşam döngüsü boyunca ne olacağını ana hatlarıyla belirtilir. Bu aşamada alınan kararlar projenin başarısında kritik öneme sahiptir.</p><p><strong>2-Analiz</strong></p><p>Yazılım projesi için ortaya konulan işler, sistem gereksinimleri ve problemler araştırılır, öne çıkarılıp ayrıntılı olarak incelenir. Bu analiz işlemi sonrasında beklentiler kesinleştirilir ve belgelenir. Bu aşamada ihtiyaçlar net bir şekilde belirlenmesi gerekmekte bu sebeple müşteri ile mühendisler arasında sağlıklı bir iletişimin kurulması önem arz etmektedir.</p><p><strong>3-Tasarım</strong></p><p>Planlama ve analiz aşamalarının tamamlanmasıyla birlikte ortaya konulacak yazılım ürünün tasarımına başlanır. Bu aşamada, sistemin mimarisi, kullanıcı arayüzü, platformu, güvenliği gibi birimler müşterinin istekleri ve sistem gereksinimleri ele alınarak tasarlanır. Oluşturulan tasarımın, ihtiyaçları karşılaması ve geleceğe yönelik yenilenebilir yapıda olması projenin başarısını etkileyecektir.</p><p><strong>4-Geliştirme</strong></p><p>Tasarım sürecinin sonlanmasıyla birlikte geliştirme süreci başlar. Geliştirme süreci diğer aşamalara göre bir nebze daha yoğundur. Bu aşamada, yazılım mühendisleri ortaya konulacak ürünün gereksinimlerini ve tasarım ögelerini koda dönüştürür. Burada yazılım mühendislerinin kodlarını belli bir kalite çerçevesinde yazması, bir başka yazılım mühendisi tarafından anlaşılabilir olması ve gelecekte güncellemeye açık olması önem arz etmektedir.</p><p><strong>5-Test</strong></p><p>Bu aşama, geliştirilen ürünün beklenildiği gibi çalışıp çalışmadığını ve gereksinimleri tam olarak karşılayıp karşılamadığı değerlendirmek için sistemin detaylı bir şekilde test edilmesidir. Ürünün belli bir kalite standartlarına ulaşması için ürün hatalarının açık bir şekilde rapor edilmesi, takip edilmesi, düzeltilmesi ve yeniden test edilmesi önemlidir.</p><p><strong>6-Teslim</strong></p><p>Ürün kapsamlı bir testten başarılı olarak geçtikten sonra ürünün müşteriye teslim edilmesidir. Teslim sırasında ürün hakkında bilgilendirici dokümanları ve kullanım bilgisini müşteriye iletmek önemlidir.</p><p><strong>7-Bakım</strong></p><p>Yazılım ürününün son kullanıcıya ulaştıktan sonraki dönemlerde ürünün hatalara karşı ve kullanıcı isteklerine göre küçük veya büyük güncellemeleri alması gerekir. Bu gereksinimler bakım aşamasında gerçekleştirilir.</p><h2><strong>Yazılım Yaşam Döngüsü Modelleri Nelerdir?</strong></h2><p><strong>1-Gelişigüzel Model</strong></p><p>1960’lı yıllarda ortaya çıkmıştır. Herhangi bir model veya yöntemi yoktur. Çoğunlukla tek kişilik ve basit projelerde kullanılır. Bu modelle oluşturulan projelerin takip edilebilirliği ve bakımı oldukça zordur. Genellikle basit programlama içerir.</p><p><strong>2-Barok Modeli</strong></p><p>1970’li yıllarda ortaya çıkmıştır. Aşamalar doğrusal bir biçimde geliştirilir. Bu modelde dokümantasyon ayrı bir süreç gibi işlenir. Aşamalar arasında geri dönüş tanımlı değildir. Daha çok projenin gerçekleştirme evresine ağırlık verilir. Bu nedenlerden ötürü günümüzde kullanılmaz.</p><p><strong>3-Çağlayan Yaşam Döngü Modeli</strong></p><p>Listedeki en eski modellerden biri olan Çağlayan yaşam döngü modelinin tarihi 1960’lara dayanıyor fakat günümüzde hala popülerliğini koruyan bir model. Çağlayan yaşam döngü modeli analiz, tasarım, kodlama, test, entegrasyon gibi aşamalardan oluşur. Bu aşamalar doğrusal bir şekilde ilerler. Bu, geliştirme sürecindeki herhangi bir aşamanın yalnızca önceki aşama tamamlandığında başlayacağı anlamına gelir. Her aşamanın sonunda doküman oluşturulur. Müşteri ve kullanıcılarla yalnızca başlangıç aşamasında diyaloğa girilir.</p><figure class=\"image\"><img src=\"https://miro.medium.com/max/368/1*2vSaqE1QjLnec1TD3r9mew.jpeg\" alt=\"\" srcset=\"https://miro.medium.com/max/276/1*2vSaqE1QjLnec1TD3r9mew.jpeg 276w, https://miro.medium.com/max/368/1*2vSaqE1QjLnec1TD3r9mew.jpeg 368w\" sizes=\"100vw\" width=\"368\"></figure><p><strong>Avantajları</strong></p><ul><li>Anlaması ve kullanması kolaydır.</li><li>Proje planlaması ve aşamalar net bir şekilde belirtilir.</li><li>Her aşamanın belirli bir sonucu olduğu için yönetimi kolaydır.</li><li>Küçük ve gereksinimleri net bir şekilde belirlenmiş projelerde kullanılması başarıyı artırır maliyeti azaltır.</li><li>Hataların her aşama sonunda doğrulanması hataların erken tespitini ve düzeltilmesini sağlar.</li><li>Küçük ve gereksinimleri net olan projelerde kısa sürede sonuca ulaşılabilir.</li></ul><p><strong>Dezavantajları</strong></p><ul><li>Tamamlanmış herhangi bir aşamaya geri dönmek zordur ve genelde projelerde önceki aşamalara dönmek zorunda kalınabilir.</li><li>Dokümantasyon işlemi çalışanların çok fazla zamanını alır. Çalışanlar bir an önce kod yazma eğiliminde oldukları için ekip moralini de etkileyebilir.</li><li>Genelde projenin tamamlanması zaman alır.</li><li>Müşteri ve kullanıcı gereksinimleri başlangıçta alınması ilerde sorun yaratabilir. Müşterinin gereksinimleri değişebilir ve bu yüzden değişen müşteri gereksinimlerini hayata geçirmek maliyeti oldukça arttırabilir.</li><li>Hatalar yalnızca bulunduğu aşamada giderilmesi ileride sorun yaratabilir.</li><li>Karmaşık projeler için uygun değildir.</li></ul><p><strong>4-V Süreç Modeli</strong></p><figure class=\"image\"><img src=\"https://miro.medium.com/max/700/1*vhiS9RKl6rnmt2s0OXeeBw.jpeg\" alt=\"\" srcset=\"https://miro.medium.com/max/276/1*vhiS9RKl6rnmt2s0OXeeBw.jpeg 276w, https://miro.medium.com/max/552/1*vhiS9RKl6rnmt2s0OXeeBw.jpeg 552w, https://miro.medium.com/max/640/1*vhiS9RKl6rnmt2s0OXeeBw.jpeg 640w, https://miro.medium.com/max/700/1*vhiS9RKl6rnmt2s0OXeeBw.jpeg 700w\" sizes=\"100vw\" width=\"700\"></figure><p>V-süreç modeli, aşamaların V şeklinde sıralı bir şekilde yürütüldüğü bir yazılım yaşam döngü modelidir. V süreç modelinde sol taraf üretim, sağ taraf sınama işlemleridir. V süreç modelinde, çağlayan yaşam döngü modelindeki gibi bir aşamadan sonraki aşamaya geçmek için tüm işler netleşmiş veya bitmiş olmalıdır. Bu modelde şelale modelinden farklı olarak geliştirme döngüsündeki her bir aşama için doğrudan ilişkili bir test aşaması vardır. Buradaki amaç sistemin düzgün ve kaliteli çalıştığından emin olarak ilerlemektir.</p><p><strong>Avantajları</strong></p><ul><li>Tüm süreci daha kolay kavramayı sağlayan çok sayıda planlama var.</li><li>Proje yönetimi tarafında takibi kolaydır.</li><li>Anlaması ve kullanması kolaydır.</li><li>Gereksinimlerin çok iyi anlaşıldığı küçük projeler için iyi sonuç verir.</li><li>Bu model oldukça disiplinli bir modeldir ve aşamalar birer birer tamamlanır. Bu nedenle yönetimi daha kolaydır. Her aşamanın belirli çıktıları ve inceleme süreci vardır.</li></ul><p><strong>Dezavantajları</strong></p><ul><li>Çağlayan yaşam döngü modeli gibi çok esnek değil.</li><li>Karmaşık ve nesneye yönelik projeler için iyi bir model değil.</li><li>Bir uygulama test aşamasındayken, geri dönüp bir işlevi değiştirmek zordur.</li><li>Ürün kodlama aşamasında geliştirildiğinden dolayı yazılımın erken prototipleri üretilmez.</li><li>Uzun ve karmaşık projeler için oldukça zaman harcar aynı zamanda maliyeti de arttırır.</li></ul><p><strong>5-Helezonik (spiral) Model</strong></p><figure class=\"image\"><img src=\"https://miro.medium.com/max/406/1*6DV29L0-7ySD-_saBUL_WA.jpeg\" alt=\"\" srcset=\"https://miro.medium.com/max/276/1*6DV29L0-7ySD-_saBUL_WA.jpeg 276w, https://miro.medium.com/max/406/1*6DV29L0-7ySD-_saBUL_WA.jpeg 406w\" sizes=\"100vw\" width=\"406\"></figure><p>Gereksinimlerin belirsiz, projenin karmaşık ve büyük olduğu durumlarda risk oldukça yüksek olur. Bu ihtiyaç doğrultusunda helezonik model ortaya çıkmıştır. Bu modelde risk analizi ve yönetimi ön plandadır. Bu durum, başta bahsettiğimiz projeler gibi projeler için riski azaltır. Planlama, Risk Analizi, Üretim ve Kullanıcı Değerlendirme fazlarından oluşur.</p><p><strong>1-Planlama</strong></p><p>Bu aşamada müşteri gereksinimleri incelenir. Bu gereksinimlere göre hedef belirlenir ve bu hedeflere göre çözüm üretilir. Kısaca proje ana hatlarıyla planlanır.</p><p><strong>2-Risk Analizi</strong></p><p>Bu aşamada risk analizi yapılır. Çözümler araştırılır ve en iyi çözüm yolu seçilir. Bu konuda ürünün bir prototipi geliştirilir.</p><p><strong>3-Üretim</strong></p><p>Seçilen çözüm yoluna göre bir ara ürün ortaya konur ve testleri yapılır. Bir sonraki faza hazırlanır.</p><p><strong>4-Kullanıcı Değerlendirme</strong></p><p>Ortaya konulan ara ürün kullanıcıya sunulur ve kullanıcı tarafından yapılan değerlendirmeler ele alınır.</p><p><strong>Avantajları</strong></p><ul><li>İş ilerledikçe proje hakkında yapılan tahminler daha gerçekçi hale gelir çünkü önemli konular daha erken ele alınır.</li><li>Risk yönetimi, projeyi parçalar halinde ele alarak daha kolay hale getirilir.</li><li>Yazılım sürekli geliştirilir. Değişime açıktır.</li><li>Her aşamada riski tespit etmek kolaydır.</li><li>Kullanıcılar sistemi erken görebilirler.</li><li>Gereksinimlerin belirsiz olduğu karmaşık ve riskli projeler için oldukça uygundur.</li></ul><p><strong>Dezavantajları</strong></p><ul><li>Projeyi bitirmek için oldukça zamana ve paraya ihtiyaç vardır.</li><li>Küçük ve karmaşık olmayan projeler için gereğinden fazla maliyetli bir çözümdür kullanılması önerilmez.</li><li>Diğer modellere göre karmaşıktır.</li><li>Çok fazla dokümantasyon gerektirir.</li><li>Spiral sonsuza kadar gidebilir.</li><li>Başlangıçta planlanandan daha farklı bir proje ile karşılaşılabilir.</li><li>Riskleri ve varsayımları değerlendirmek için özel becerilere ihtiyaç duyar.</li></ul><p><strong>6-</strong> <strong>Artımsal Geliştirme Süreç Modeli</strong></p><p>Artımsal geliştirme süreç modeli, müşteriye yazılımı parça parça geliştirip teslim etmeye dayanır. Müşterinin gereksinimleri belirlenir ve bu gereksinimler, birden çok bağımsız modüle bölünen yazılım geliştirme sürecine dahil edilir. Her bir yazılım bir öncekinin üstüne bazı ek işlevler ekler. Bu modelde bir taraftan üretim bir taraftan da kullanım yapılır. Her bir yazılım parçasının birbirinden olabildiğince ayrı olması ve birbirleri ile entegrasyon ihtiyaçlarının az olması sayesinde model başarılı olur.</p><p>Bu model;</p><ul><li>Sistem gereksinimleri açıkça anlaşılır.</li><li>Ürünün erken piyasaya sürülmesi gerektiğinde</li><li>Yüksek riskli ve karmaşık hedefler söz konusu olduğunda</li><li>Yazılım mühendisliği ekibinin yetersiz veya sayısı az olduğunda</li></ul><p>Kullanıma uygundur.</p><figure class=\"image\"><img src=\"https://miro.medium.com/max/665/1*ZvopgNgOgafNKudHzJzaCA.jpeg\" alt=\"\" srcset=\"https://miro.medium.com/max/276/1*ZvopgNgOgafNKudHzJzaCA.jpeg 276w, https://miro.medium.com/max/552/1*ZvopgNgOgafNKudHzJzaCA.jpeg 552w, https://miro.medium.com/max/640/1*ZvopgNgOgafNKudHzJzaCA.jpeg 640w, https://miro.medium.com/max/665/1*ZvopgNgOgafNKudHzJzaCA.jpeg 665w\" sizes=\"100vw\" width=\"665\"></figure><p><strong>Avantajları</strong></p><ul><li>Yazılım hızlı bir şekilde üretilir.</li><li>Gereksinimler müşterilerle belirlenir.</li><li>Gereksinimler önemine göre sıralanır ve önce en önemli gereksinimi karşılayan bir yazılım geliştirilir.</li><li>Gereksinimleri ve kapsamı değiştirmek esnektir ve daha ucuzdur.</li><li>Projenin başarısız olma riskini azaltır.</li><li>Hataları tanımlaması kolaydır.</li></ul><p><strong>Dezavantajları</strong></p><ul><li>Kusursuz ve iyi bir planlama gerektirir.</li><li>Yazılım yaşam döngüsünün tamamı için tüm gereksinimler önceden toplanmadığı için sistem mimarisi nedeniyle ilgili sorunlara neden olabilir.</li><li>Deneyimli personel gerektirir.</li><li>Her artırım aşaması katıdır ve birbiriyle örtüşmez.</li><li>Tek bir modülde bir problemi gidermek, tüm modüllerde düzeltme gerektirebilir. Bu nedenden ötürü sistem çok zaman ve para harcayabilir.</li></ul><p><strong>7-Kodla ve Düzelt Yaşam-Döngü Modeli</strong></p><p>Kodla ve düzelt yaşam döngü modelinde en kısa sürede prototipleyerek sonuca ulaşma amaçlanır. Kodla ve düzelt modeli cowboy coding olarak da adlandırılır. Diğer modellere kıyasla proje gerçekleştirme öncesi planlama, analiz gibi aşamalar üzerinde çok vakit harcanmaz. Ana problemlere odaklanılır.</p><figure class=\"image\"><img src=\"https://miro.medium.com/max/466/1*5KSPLD7FUvc0Pupv3uUKSQ.jpeg\" alt=\"\" srcset=\"https://miro.medium.com/max/276/1*5KSPLD7FUvc0Pupv3uUKSQ.jpeg 276w, https://miro.medium.com/max/466/1*5KSPLD7FUvc0Pupv3uUKSQ.jpeg 466w\" sizes=\"100vw\" width=\"466\"></figure><p><strong>Avantajları</strong></p><ul><li>Planlama ve analize çok zaman harcanmaz.</li><li>Projeyi bir an önce gerçekleştirmek için kullanılabilir.</li><li>Kişisel kullanıma uygundur.</li><li>Çok küçük ve basit projeler için kullanılabilir.</li><li>Amatör ve yeni başlayan mühendisler için kullanması en kolay modeldir.</li></ul><p><strong>Dezavantajları</strong></p><ul><li>Sisteme ait dokümantasyon olmadığı için bakım aşaması zordur.</li><li>Plansız olduğu için kontrollü değildir.</li><li>Kodlama aşaması planlanmadığından sonradan yapılmak istenen değişiklikler maliyetli ve değiştirilmesi zor olur.</li><li>Projenin bitiş süresi tam kestirilemez</li></ul><h2><strong>Çevik Yazılım Geliştirme (Agile Software Development) Nedir?</strong></h2><p>2001’de Utah’ta yaşayan 17 yazılım mühendisi tarafından geliştirilen ve en ünlü SDLC metodu olan Çevik yazılım geliştirme modeli, hızla değişen dünyamıza ayak uyduran, yazılım geliştirmeye yönelik insan ve sonuç odaklı bir yaklaşımdır. Çevik yazılım geliştirme modelinin bir de manifestosu vardır. Bu manifestoda:</p><p>Süreçler ve araçlardan ziyade <strong>bireyler ve etkileşimlere</strong></p><p>Kapsamlı dokümantasyondan ziyade <strong>çalışan yazılıma</strong></p><p>Sözleşme pazarlıklarından ziyade <strong>müşteri ile işbirliğine</strong></p><p>Bir plana bağlı kalmaktan ziyade <strong>değişime karşılık vermeye,</strong></p><p>Değer verildiği vurgulanmıştır.</p><figure class=\"image\"><img src=\"https://miro.medium.com/max/539/1*iz9gdmOy0QqcltQc0YEOlQ.jpeg\" alt=\"\" srcset=\"https://miro.medium.com/max/276/1*iz9gdmOy0QqcltQc0YEOlQ.jpeg 276w, https://miro.medium.com/max/539/1*iz9gdmOy0QqcltQc0YEOlQ.jpeg 539w\" sizes=\"100vw\" width=\"539\"></figure><p>Çevik yazılım geliştirme modelinde büyük projeler daha küçük parçalara bölünür bu parçalar yinelemeler (iterations) olarak adlandırılır. Her yineleme, çevik yazılım geliştirme sürecinin tipik aşamalarından geçer. Bu aşamalar planlama, tasarım, gerçekleştirme, test, dağıtım ve bakımdır. Her yinelemenin tamamlanması yaklaşık olarak 2–4 hafta sürer ve sonra piyasaya sürülüp geri bildirimler alınır. Bu yönleriyle çevik yaşam geliştirme modeli verimli, esnek, hızlı ve oldukça kullanışlıdır. Çevik yazılım geliştirme modeli kapsamına giren bir çok metodoloji vardır. Bunlardan en popülerleri Extreme Programing(xp) ve Scrum’dır.</p><h2><strong>Extreme Programing(XP)</strong></h2><p>Extreme Programing(XP), en popüler çevik yazılım geliştirme metodolojilerinden biridir. Yazılım kalitesini arttırmak ve müşteri gereksinimlerini en iyi şekilde yanıt vermek için kullanılır. Geri bildirim ve iletişime oldukça önem verir. XP’nin 5 temel değeri vardır. Bunlar:</p><ol><li>Basitlik</li><li>İletişim</li><li>Kullanıcı geri bildirimi</li><li>Cesaret</li><li>Saygı</li></ol><p><strong>Basitlik</strong></p><p>XP de kullanılacak en basit ve en verimli yöntem seçilmelidir. Karmaşık çözümler XP’ye aykırıdır. Yazılımın o anki gereksinimlerini minimum şekilde karşılayacak en basit çözüm doğrudur.</p><p><strong>İletişim</strong></p><p>İletişim projenin başarılı olması için gerekli olan en önemli faktörlerden biridir. Ancak doğru ve karşılıklı anlaşılan bir iletişim sorunların çözümüne yardımcı olacaktır. Bu yüzden XP, yüzyüze iletişime oldukça önem verir. Ürünün üreticileri ve kullanıcıları arasında sağlıklı bir iletişimin sağlanması ürünün başarılı,gereksinimleri tam olarak karşılama olasılığını arttır</p><p><strong>Kullanıcı geri bildirimi</strong></p><p>Ürünün son kullanıcıya ulaşması ile birlikte kullanıcılardan geri bildirim almak oldukça önemlidir. Bu geri bildirimler sayesinde ortaya koyulan yazılım ürününün, hatalarından arındırılması ve ürüne yeni özelliklerin eklenmesi işleri kolaylaştırır.</p><p><strong>Cesaret</strong></p><p>Cesaret belki de XP’nin en zor değerinden biridir. Cesaret, başarıyı sağlamak için oldukça önemli bir adımdır. Yazılım mühendisleri yeni teknolojilere, yeni hatalara, yeni sorunlarla baş etmek için cesaretli olmalıdır. Hata yapmaktan korkmamalı ve hatanın kaynağını araştırmalıdır.</p><p><strong>Saygı</strong></p><p>Çalışanların kendilerine saygı duyması yapılan işin kalitesini arttırır. Saygı, ekip arkadaşlarınızla bağlanmanıza ve daha iyi bir çalışma ortamının oluşmasını sağlar. Bu ortaya konulan ürünün kalitesini de etkileyecektir.</p><h2><strong>Scrum</strong></h2><p>Scrum, büyük, riskli ve karmaşık yazılım projelerini yinelemeli bir şekilde geliştirmeyi öngören bir çevik yazılım geliştirme metodolojisidir. Scrum, yazılım işlerini <strong>sprint</strong> adı verilen zaman dilimlerine böler. Her sprint 2–4 hafta arası sürer. Bu şekilde karmaşık ve yönetilmesi zor olan projeler parçalara ayrılarak yönetilmesi kolay hale getirilir. Scrum metodolojisinde 3 önemli rol vardır. Bunlar ürün sahibi, scrum yöneticisi ve scrum takımıdır.</p><p><strong>Ürün sahibi</strong></p><p>Ürün sahibi, müşterilerden ve kullanıcılardan geri dönüşleri alır. Gereksinimleri, öncelikleri ve Product Backlog’u belirler.</p><p><strong>Scrum Yöneticisi</strong></p><p>Scrum’un kurallarına, yapısına hâkim ve bunları uygulamasından sorumlu kişidir.</p><p><strong>Scrum Takımı</strong></p><p>Her sprint başında belirlenen hedefe birlikte yürüten, projeyi geliştiren ve gerekli teknik bilgiye sahip bir grup profesyonel kişiler.</p><figure class=\"image\"><img src=\"https://miro.medium.com/max/700/1*bW8MjoLKMTt-T4mlr_25Tg.jpeg\" alt=\"\" srcset=\"https://miro.medium.com/max/276/1*bW8MjoLKMTt-T4mlr_25Tg.jpeg 276w, https://miro.medium.com/max/552/1*bW8MjoLKMTt-T4mlr_25Tg.jpeg 552w, https://miro.medium.com/max/640/1*bW8MjoLKMTt-T4mlr_25Tg.jpeg 640w, https://miro.medium.com/max/700/1*bW8MjoLKMTt-T4mlr_25Tg.jpeg 700w\" sizes=\"100vw\" width=\"700\"></figure><p><strong>Scrum Daily Meetings (Günlük Scrum Toplantısı)</strong></p><p>Scrum Daily Meetings, her gün aynı yerde ve aynı saatte ayakta gerçekleştirilen kısa bir toplantıdır. Bu toplantıda takım, bir önceki gün yapılan işleri gözden geçirir ve sonraki 24 saatte için hangi işlerin yapılıp yapılmayacağı planlanır. Yaşanan sorunlar hakkında tartışma yapılır ve çözüm aranır.</p><p><strong>Product Backlog (Ürün Biriktirme Listesi)</strong></p><p>Product Backlog, birikmiş işlerin müşteri ile anlaşılıp yüksek gereksinimli işlerin önceliklendirildiği bir listedir.</p><p><strong>Sprint backlog (Sprint Biriktirme Listesi)</strong></p><p>Geliştirme takımı tarafından, üzerinde çalışacakları sprint sırasında gerçekleştirmek için önceliklerine göre sıralanmış bir yapılacaklar listesidir.</p><h2>Kaynaklar</h2><ul><li><a href=\"https://medium.com/@denizkilinc/yaz%C4%B1l%C4%B1m-ya%C5%9Fam-d%C3%B6ng%C3%BCs%C3%BC-temel-a%C5%9Famalar%C4%B1-software-development-life-cycle-core-processes-197a4b503696\"><strong>https://medium.com/@denizkilinc/yazılım-yaşam-döngüsü-temel-aşamaları-software-development-life-cycle-core-processes-197a4b503696</strong></a></li><li><a href=\"https://www.tutorialspoint.com/sdlc/sdlc_overview.htm\"><strong>https://www.tutorialspoint.com/sdlc/sdlc_overview.htm</strong></a></li><li><a href=\"https://stackify.com/what-is-sdlc/\"><strong>https://stackify.com/what-is-sdlc/</strong></a></li><li><a href=\"https://blog.codegiant.io/software-development-life-cycle-the-ultimate-guide-2020-153d17bb20fb\"><strong>https://blog.codegiant.io/software-development-life-cycle-the-ultimate-guide-2020-153d17bb20fb</strong></a></li><li><a href=\"https://blog.codegiant.io/software-development-life-cycle-the-ultimate-guide-2020-153d17bb20fb\"><strong>https://blog.codegiant.io/software-development-life-cycle-the-ultimate-guide-2020-153d17bb20fb</strong></a></li><li><a href=\"https://www.intellectsoft.net/blog/what-is-system-development-life-cycle/\"><strong>https://www.intellectsoft.net/blog/what-is-system-development-life-cycle/</strong></a></li><li><a href=\"https://www.konstantinfo.com/blog/software-development-life-cycle/#:~:text=SDLC%20Methodologies%20are%20used%20to,primitive%20approach%20for%20software%20development\"><strong>https://www.konstantinfo.com/blog/software-development-life-cycle/#:~:text=SDLC%20Methodologies%20are%20used%20to,primitive%20approach%20for%20software%20development</strong></a><strong>.</strong></li><li><a href=\"https://www.codex.com.tr/yazilim-gelistirme-modelleri\"><strong>https://www.codex.com.tr/yazilim-gelistirme-modelleri</strong></a></li><li><a href=\"https://medium.com/architectural-patterns/yaz%C4%B1l%C4%B1m-geli%C5%9Ftirme-modelleri-62915545c51e\"><strong>https://medium.com/architectural-patterns/yazılım-geliştirme-modelleri-62915545c51e</strong></a></li><li><a href=\"https://agiletech.vn/top-software-development-life-cycle-models/\"><strong>https://agiletech.vn/top-software-development-life-cycle-models/</strong></a></li><li><a href=\"https://fikirjeneratoru.com/yazilim-proje-yonetimi-yontemleri/\"><strong>https://fikirjeneratoru.com/yazilim-proje-yonetimi-yontemleri/</strong></a></li><li><a href=\"https://existek.com/blog/sdlc-models/\"><strong>https://existek.com/blog/sdlc-models/</strong></a></li><li><a href=\"https://www.digite.com/agile/scrum-methodology/#:~:text=Scrum%20is%20an%20agile%20development,the%20development%20of%20the%20project\"><strong>https://www.digite.com/agile/scrum-methodology/#:~:text=Scrum%20is%20an%20agile%20development,the%20development%20of%20the%20project</strong></a><strong>.</strong></li><li><a href=\"https://agilemanifesto.org/\"><strong>https://agilemanifesto.org</strong></a></li><li><a href=\"https://medium.com/@denizkilinc/yaz%C4%B1l%C4%B1m-ya%C5%9Fam-d%C3%B6ng%C3%BCs%C3%BC-temel-a%C5%9Famalar%C4%B1-software-development-life-cycle-core-processes-197a4b503696\"><strong>https://medium.com/@denizkilinc/yazılım-yaşam-döngüsü-temel-aşamaları-software-development-life-cycle-core-processes-197a4b503696</strong></a></li></ul>", "article_image" : "1641322472754-925763414.jpeg", "user" : { "$oid" : "61d4969245c4f24b6c575114" }, "likes" : [ { "$oid" : "61d4969245c4f24b6c575114" }, { "$oid" : "61d496ac45c4f24b6c575123" }, { "$oid" : "61d496f745c4f24b6c57513a" }, { "$oid" : "61d4971b45c4f24b6c575149" } ], "likeCount" : 4, "comments" : [ { "$oid" : "61d49c5845c4f24b6c57549e" } ], "createdAt" : { "$date" : "2022-01-04T18:54:32.756+0000" }, "slug" : "yazilim-yasam-dongu-modelleri", "__v" : 5 },
{ "_id" : { "$oid" : "61d4983445c4f24b6c57518c" }, "title" : "OWASP Top 10 (2020)", "description" : "OWASP (Open Web Application Security Project), web uygulama güvenliği alanına kendini adamış kâr amacı gütmeyen uluslararası bir kuruluştur. Temel ilkelerinden biri de herkesin kendini web uygulama güvenliği alanında geliştirebilmesi için ürettiği makalelere, metodolojilere, dokümantasyonlara, araçlara ve teknolojilere ücretsiz ulaşmasını sağlamaktır. OWASP’ın bu alanda en çok popüler olan projelerinden biri de OWASP Top 10’dir.", "content" : "<p><strong>OWASP Top 10</strong></p><p>OWASP (Open Web Application Security Project), web uygulama güvenliği alanına kendini adamış kâr amacı gütmeyen uluslararası bir kuruluştur. Temel ilkelerinden biri de herkesin kendini web uygulama güvenliği alanında geliştirebilmesi için ürettiği makalelere, metodolojilere, dokümantasyonlara, araçlara ve teknolojilere ücretsiz ulaşmasını sağlamaktır. OWASP’ın bu alanda en çok popüler olan projelerinden biri de OWASP Top 10’dir.</p><p><strong>Nedir bu OWASP Top 10?</strong></p><p>OWASP Top 10 en yaygın 10 uygulama güvenlik açığının bir listesidir. Bu listede aynı zamanda açıkların riskleri, etkileri ve bu açıklara karşı önlemler de bulunur. Her üç veya dört yılda bir düzenli olarak güncellenir.</p><p><strong>OWASP Top 10 Güvenlik Açıkları</strong> (<i>2020 yılı için</i>)</p><p><strong>1.</strong> <strong>Injection</strong></p><p><strong>2.</strong> <strong>Broken Authentication</strong></p><p><strong>3.</strong> <strong>Sensitive Data Exposure</strong></p><p><strong>4.</strong> <strong>XML External Entities (XXE)</strong></p><p><strong>5.</strong> <strong>Broken Access Control</strong></p><p><strong>6.</strong> <strong>Security Misconfigurations</strong></p><p><strong>7.</strong> <strong>Cross Site Scripting (XSS)</strong></p><p><strong>8.</strong> <strong>Insecure Deserialization</strong></p><p><strong>9.</strong> <strong>Using Components With Known Vulnerabilities</strong></p><p><strong>10.</strong> <strong>Insufficent Logging and Monitoring</strong></p><p><strong>1.Injection (Enjeksiyon)</strong></p><p>Injection zafiyetleri genellikle kullanıcıdan alınan verilerin, kontrol edilmemesinden veya(*) herhangi bir filtreleme olmadan komut olarak çalıştırılmasıyla ya da sorguya dahil edilmesiyle ortaya çıkar.</p><p>Injection zafiyeti sayesinde saldırgan zararlı bir veri göndererek sistemde komut çalıştırabilir hatta erişmemesi gereken verilere bile erişebilir hale gelebilir. Saldırgan sistemde komut çalıştırabilir hale geldiğinde hak yükseltme zafiyetlerini kullanarak sistem üzerindeki etkinliğini daha da arttırabilir. Böyle bir durum söz konusu olduğunda ise organizasyon içinde çok büyük sorunlara yol açabilir. Böylesine bir zafiyet çok riskli olduğundan listenin bir numarasında yer alır.</p><p>En yaygın Injection türleri SQL Injection ve Command Injection’dır. İki injection türü de yukarıda da bahsettiğimiz gibi gelen verilerin kontrol edilmemesinden veya (*) filterelenmeden alınmasından kaynaklanmaktadır.</p><p>· <strong>SQL Injection</strong></p><p>Bu injection türü kullanıcıdan alınan verinin direkt olarak sql sorgusuna dahil edilmesinden kaynaklanmaktadır.</p><p><strong>Örnek :</strong></p><p><strong>“ </strong><a href=\"http://ornek.com/haberler.php?read=185\"><strong>http://ornek.com/haberler.php?read=185</strong></a><strong> “</strong></p><p>Örnek web sayfası read parametresindeki değeri sql sorgusu ile veritabanında kayıtlı olan haberler arasından bulup kullanıcıya gösterilmesini sağlıyor. Bu sayfayı ziyaret ettiğimizde aşağıdaki gibi bir sql sorgusu çalışıyor.</p><p><strong>“ SELECT*FROM haberler WHERE id=185 ”</strong></p><p>Bu sql sorgusunda şu ana kadar hiçbir sıkıntı yok fakat bir saldırgan beklenilmeyen bir parametre girerse sistem açısından risk oluşturacaktır. Saldırganın şu şekilde bir parametre girdiğini düşünelim.</p><p><strong>“</strong> <a href=\"http://ornek.com/haberler.php?read=**185\"><strong>http://ornek.com/haberler.php?read=**185</strong></a><strong>; DROP ALL TABLES; — ”</strong></p><p>Bu sayfa çalıştığında arkaplanda şu şekilde bir sql sorgusu çalışacaktır.</p><p>“ <strong>SELECT*FROM haberler WHERE id=185; DROP ALL TABLES; — ”</strong></p><p>Bu sql sorgusu çalıştığında veritabanındaki tüm tablolar silinecektir. Tabii ki SQL Injection’un tek işe yaradığı şey tablo silmek değildir. Veritabanındaki tüm tablolardaki verileri görebilir hatta komut çalıştırabilirsiniz. Saldırganın SQL Injection yöntemiyle bütün yönetici hesap bilgileri ve şifrelerine eriştiğini düşünün. Bu sistem için gerçekten çok sıkıntılı bir durum yaratacaktır.</p><p>· <strong>Command Injection</strong></p><p>Command Injection da SQL Injeciton da olduğu gibi alınan verinin kontrol edilmemesinden kaynaklanan zafiyettir.</p><p><strong>Örnek :</strong></p><p><strong>“ </strong><a href=\"http://ornek.com/admin/command.php?*command*=**deneme.txt**\"><strong>http://ornek.com/admin/command.php?*command*=**deneme.txt**</strong></a><strong> ”</strong></p><p>Örnek web sayfası aldığı command parametresine verdiğimiz değer isminde sistem üzerinde bir dosya oluşturuyor. Bu sayfanın kaynak kodları ise aşağıdaki gibi olsun.</p><figure class=\"image\"><img src=\"https://miro.medium.com/max/207/1*14O_Nu0xMUwqk036HO7Omw.png\" alt=\"\"></figure><p>Kullanıcı bir dosya oluşturmak istediğinde sistemde “ <i><strong>touch deneme.txt</strong></i> ” komudu çalışacaktır. Komutumuz düzgün bir şekilde çalışıyor.</p><p>Saldırgan şu şekilde bir değer veriyor olsun.</p><p>“ <a href=\"http://ornek.com/admin/command.php?command=**deneme.txt\">http://ornek.com/admin/command.php?command=**deneme.txt</a>; reboot**</p><p>Böyle bir durumda sistemde “ <i><strong>touch deneme.txt; reboot </strong></i>” komutu çalışıyor. Böylesi bir komutta dosya oluşturulur ardından ise sistem yeniden başlatılır. Yani buradan anlaşıldığı üzere Command Injection zafiyetiyle sistem üzerinde istediğiniz komudu çalıştırabilir hale gelebilirsiniz.</p><p><strong>2.Broken Authentication (Yanlış Kimlik Doğrulama)</strong></p><p>Broken Authentication zafiyeti genellikle kimlik doğrulama ve oturum yöntemiyle ilgili mekanizmalar yanlış uygulandığında veya ayarlandığında ortaya çıkar. Saldırganlar bu zafiyetten yararlanarak parolaları, session tokenları ele geçirebilir. Böylece sistemi istismar etmesi kolaylaşır.</p><p>Saldırganlar genellikle brute force (kaba kuvvet) saldırıları yaparak kullanıcıların kimliklerini açığa çıkarabilirler. Bu yüzden sıradan parolaların (admin, admin123, 123456 gibi parolalar) kullanımı saldırganların işini kolaylaştırarak kolayca sisteme sızmalarına neden olur.</p><p><strong>3.Sensitive Data Exposure (Veri İfşası)</strong></p><p>Web uygulamalarının hassas verileri (kredi kartı bilgileri, parolalar, kişisel kayıtlar vb.) gerektiği gibi korumamasından kaynaklanan zafiyettir. Örnek verecek olursak; verilerin şifrelenmemesi, şifrelenen verilerin eski, açığa çıkmış şifreleme algoritmasıyla saklanması gibi nedenlerden bahsedebiliriz. Aynı zamanda bilgiler clienttan sunucuya aktarılıyorken şifrelenmeden veya açığa çıkmış şifreleme algoritmaları kullanılarak aktarılırsa yine bu zafiyetten bahsedebiliriz. Güçlü şifreleme algoritmalarının kullanılması sayesinde bu gibi durumların önüne geçilebilir. Saldırgan sql injection zafiyetini kullansa dahi algoritmalar çözülemediği için saldırganın verilere ulaşmasını engelleyecektir.</p><p><strong>4.XML External Entities (XXE)</strong></p><p>Bu zafiyet verilerin Parsing(ayrıştırma) işlemi sırasında meydana gelir. Saldırgan verilerin işlenmesi esnasında müdahale ederek sunucudan dosya okuyabilir ve kod çalıştırabilir hale gelir.</p><p><strong>Örnek :</strong></p><figure class=\"image\"><img src=\"https://miro.medium.com/max/504/1*Mfp30duPd6TN3sqdHML-tA.png\" alt=\"\" srcset=\"https://miro.medium.com/max/276/1*Mfp30duPd6TN3sqdHML-tA.png 276w, https://miro.medium.com/max/504/1*Mfp30duPd6TN3sqdHML-tA.png 504w\" sizes=\"100vw\" width=\"504\"></figure><p>Örnek kodumuzda kullanıcıdan dosya alıp ekrana yazdırma işlemini sağlıyoruz.</p><figure class=\"image\"><img src=\"https://miro.medium.com/max/191/1*OD8gc0TPSVJ6QSV_ZutUoQ.png\" alt=\"\"></figure><p>Normalde bu şekilde xml dosyamızı sunucuya göndeririz.</p><figure class=\"image\"><img src=\"https://miro.medium.com/max/451/1*8Gt54dhF_kurqUG9iLNdtg.png\" alt=\"\" srcset=\"https://miro.medium.com/max/276/1*8Gt54dhF_kurqUG9iLNdtg.png 276w, https://miro.medium.com/max/451/1*8Gt54dhF_kurqUG9iLNdtg.png 451w\" sizes=\"100vw\" width=\"451\"></figure><p>Fakat saldırgan bu şekilde bir xml dosyası göndererek sunucuda dosya okuyabilir hale gelebiliyor. Bu dosya sisteme aktarıldığında sunucuda bulunan kullanıcıların olduğu dosya saldırgan tarafından okunabilir hale gelir.</p><p><strong>5.Broken Access Control (Yanlış Giriş Kontrolü)</strong></p><p>Bu zafiyet türünde sistemdeki kullanıcıların neler yapabileceğinin düzgün bir şekilde ayarlanmamasından kaynaklanır. Saldırganlar bu zafiyetleri kullanarak izni olmayan dosyalara erişebilir, yetkisi dışındaki fonksiyonları veya özellikleri kullanabilir, diğer kullanıcıların verilerine erişebilir.</p><p><strong>Örnek :</strong></p><p><a href=\"http://ornek.com/kullanici.php?**kullanici=sedat**\"><strong>http://ornek.com/kullanici.php?**kullanici=sedat**</strong></a></p><p>Bu websitesine giriş yapıldığında sedat isimli kullanıcı kendi bilgilerine erişebiliyor olsun.</p><p><a href=\"http://ornek.com/kullanici.php?**kullanici=ahmet**\">http://ornek.com/kullanici.php?**kullanici=ahmet**</a></p><p>Saldırgan “kullanici” parametresini yukarıdaki gibi değiştirdiğinde artık ahmet isimli kullanıcının bilgilerine erişebilir hale gelir. Hatta parametreyi istediği gibi değiştirerek başka kullanıcıların bilgilerini de görebilir.</p><p><strong>6.Security Misconfiguration (Yanlış Güvenlik Yapılandırması)</strong></p><p>Bu zafiyet türünün ortaya çıkması servis ayarlarının yanlış ya da eksik yapılmasından kaynaklanır. Örnek verecek olursak; gereksiz servis ve eklentilerin yüklenmesi, servislerin veya eklentilerin varsayılan yapılandırmalarının değiştirilmemesi ya da kaldırılamaması, servislerin güncel tutulmaması gibi örnekler verebiliriz.</p><p><strong>7.Cross Site Scripting (XSS)</strong></p><p>Bu zafiyet genellikle kullanıcıdan alınan verilerin, kontrol edilmemesinden veya(*) herhangi bir filtreleme olmadan html response olarak gönderilmesi sonucu oluşur. Bu zafiyet sayesinde saldırganlar kullanıcı tarayıcısında zararlı kod çalıştırarak kullanıcı oturumunu ele geçirebilirler.</p><p>· <strong>Reflected XSS</strong></p><p>Reflected XSS, anlık olarak kullanıcıdan (?) alınan verinin html response’a eklenip kullanıcının tarayıcısında kod çalıştırılabilinmesidir. Bu zafiyet genelde linklere tıklanmasıyla oluşur.</p><p><strong>Örnek :</strong></p><p><a href=\"http://ornek.com/index.php?ad=%3c&amp;script%3ealert(\"><strong>http://ornek.com/index.php?ad=&lt;&amp;script&gt;alert(“Reflected XSS Zafiyeti”);&lt;/&amp;script</strong></a><strong>&gt;</strong></p><p>· <strong>Stored XSS</strong></p><p>Stored XSS‘i Reflected XSS’ten ayıran özellik Stored XSS’in sunucu tarafında çalışıyor olmasıdır. Fakat Reflected XSS’ten daha fazla zarar verme potansiyeline sahiptir. Çünkü Reflected XSS’te etkilenen sadece linke tıklayan kişidir. Stored XSS’te ise o sayfayı görüntüleyen bütün kullanıcılar etkilenir.</p><p>· <strong>DOM XSS</strong></p><p>DOM XSS zafiyeti html üzerinde değil de DOM objeleri üzerinde etki ediyor. Diğer XSS türlerinde olduğu gibi bu türde de kullanıcının tarayıcısı üzerinde kod çalıştırılmasına neden oluyor.</p><p><strong>8.Insecure Deserialization</strong></p><p><strong>Serialization :</strong> Bir objenin disk üzerine yazabileceğimiz bir yapıya çevirme işlemidir.</p><p><strong>Deserialization :</strong> Serialize edilmiş bilginin tekrar objeye çevrilmesine denir.</p><p>Bu zafiyet zararlı girdinin deserialization işlemi sonucunda ortaya çıkıyor. Bu zararlı girdi deserialization işlemi sonunda çalışabilir hale geldiğinden uzaktan kod yürütülebilmesine neden olmaktadır. Bu yüzden gelen verilerin kontrol edilmesi gerekir.</p><p><strong>9.Using Components With Known Vulnerabilities (Bilinen Güvenlik Açıklarına Sahip Bileşenleri Kullanma)</strong></p><p>Bu zafiyet türü sistemde kullanılan bileşenlerin yani servislerin, uygulamaların, kütüphanlerin, eklentilerin eski ve bilinen açıkları olan sürümlerinin kullanılması sonucu oluşur. Saldırganlar bu bileşenlerin sürümlerini bulduğu zaman bilinen açıklarından yararlanıp sistemleri ele geçirebilirler.</p><p><strong>10.Insufficient Logging and Monitoring (Yetersiz Kayıt ve İzleme)</strong></p><p>Sistemlerde loglama(kayıt girdisi) ve monitoring(izleme) işlemlerinin yapılamamasından veya gerektiği kadar yapılmamasından kaynaklı olarak saldırganların sistemlere daha fazla saldırmasına, sistemde fark edilmemesine, sistemde kalıcılığını sürdürmesine, verileri kurcalamasına olanak tanır. Bu nedenle Giriş çıkışlar, başarısız giriş denemeleri, transferler ve önemli faaliyetler loglanmalı ve monitoring işlemi yani sistemin sürekli olarak kontrol edilip gerektiği yerde yöneticilerin uyarılması gerekmektedir. Örnek olarak saldırgan bruteforce yaparken ki giriş denemeleri loglanır ve izlenirse belli sayıda başarısız giriş denemelerinden sonra sistem yöneticilerinin dikkatini çekecek ve saldırının engellenmesine olanak sağlayacaktır.</p><p><i>CSRF ve IDOR OWASP TOP 10 2020 listesinde olmasa da bu yazımda bahsetmek istedim.</i></p><p><strong>CSRF (Cross-Site Request Forgery) (Siteler Arası İstek Sahteciliği)</strong></p><p>CSRF kısaca bir websitesinin açığından yararlanarak website kullanıcılarının isteği dışında sanki o kullanıcıymış gibi erişerek işlem yapılmasına verilen addır.</p><p>Bu saldırıda daha önce kimliği doğrulanmış bir web sitesi aracılığıyla bir web uygulamasına istek gönderen bir bağlantı bulunur. Bu bağlantıya daha önceden sisteme girmiş olan kullanıcı tıkladığında websitesine istek kullanıcı tarafından gönderilir. Bu işlem kullanıcı tarafından yani kimliği doğrulanmış bir hesap tarafından yapıldığı için web sitesi isteği doğrular ve bu isteğe yanıt verir. Böylece saldırgan istediği işlemi yapmış olur.</p><p>Örneğin bir saldırgan bir banka hesabından para çekme talebinde bulunacak bir link hazırladı. Bu linki hesabı tarayıcısında açık olan birilerine gönderdi. Linke tıklandığı zaman websitesi para çekme talebine yanıt verecek ve böylece para saldırgana transfer edilmiş olacaktır. Yine bu yöntemle kullanıcının bilgilerine dahi erişilebilir.</p><p><strong>IDOR (Insecure Direct Object References) (Güvenli Olmayan Doğrudan Nesne Referansı)</strong></p><p>IDOR kısaca kullanıcıdan istenen bir bilginin bir dosya ile doğrudan iletişim kurması ile ortaya çıkan zafiyettir. Bu zafiyet yöneticinin izni olmadan dosyaya ve içeriğine ulaşmamızı sağlar. Bu zafiyet komutların kontrol edilmemesinden kaynaklanır.</p><p>Örnek verecek olursak; bir websitesinden alışveriş yapıyorsunuz. Sepet tutarınız 1250 TL olsun. Bu zafiyet bu websitesinde bulunuyorsa siz sepet tutarını istediğiniz gibi değiştirebilir hale gelebilirsiniz.</p><p>Kaynakça</p><p>[1]<a href=\"https://umuttosun.com/owasp-top-10/\">https://umuttosun.com/owasp-top-10/</a></p><p>[2]<a href=\"https://fthcyber.com/2020/09/25/owasp-top-10-guvenlik-riskleri-ve-aciklari/\">https://fthcyber.com/2020/09/25/owasp-top-10-guvenlik-riskleri-ve-aciklari/</a></p><p>[3]<a href=\"https://gelecegiyazanlar.turkcell.com.tr/blog/xml-external-entity-injection-xxe-zafiyeti\">https://gelecegiyazanlar.turkcell.com.tr/blog/xml-external-entity-injection-xxe-zafiyeti</a></p><p>[4]<a href=\"https://hasscript.com/1791/insecure-deserialization-nedir\">https://hasscript.com/1791/insecure-deserialization-nedir</a></p><p>[5]<a href=\"https://www.cloudflare.com/learning/security/threats/owasp-top-10/\">https://www.cloudflare.com/learning/security/threats/owasp-top-10/</a></p><p>[6]<a href=\"https://www.beyaz.net/tr/guvenlik/makaleler/siteler_arasi_istek_sahteciligi_csrf_cross_site_request_forgery_nedir.html\">https://www.beyaz.net/tr/guvenlik/makaleler/siteler_arasi_istek_sahteciligi_csrf_cross_site_request_forgery_nedir.html</a></p>", "article_image" : "1641322548177-121054179.png", "user" : { "$oid" : "61d496ac45c4f24b6c575123" }, "likes" : [ { "$oid" : "61d4969245c4f24b6c575114" } ], "likeCount" : 1, "comments" : [  ], "createdAt" : { "$date" : "2022-01-04T18:55:48.178+0000" }, "slug" : "owasp-top-10-2020", "__v" : 1 },
{ "_id" : { "$oid" : "61d4994545c4f24b6c5751b3" }, "title" : "Yazılım Proje Şablonu: Basit ve herkese lazım…", "description" : "Yazılım iş fikirlerinizi somutlaştırın.", "content" : "<p>Bir fikrim var ama nasıl bir yol haritası izleyeceğimi bilmiyorum. Hatta içerisinde birçok yazılım bileşeni var (yapay zeka bile var) ancak nasıl bir planlama yapacağım, bu iş için nelere ihtiyacım var, planı nasıl yapacağım, riskler neler gibi aklıma birçok soru geliyor. İş planları, kanvas modelleri vs. gibi farklı kaynaklardan okuyorum ama hepsini bir araya getiremiyorum. İşte tam da bu noktada yazılım projesini şekillendirmek ile ilgili <i>az derli toplu</i> ama <i>basit ve anlaşılır</i> bir dokümana ihtiyacınız olacaktır.</p><p>Öncelikle şunu belirteyim, 20 senedir farklı birçok projenin içerisinde yer alan birisiyim ve bu doküman;</p><ul><li>SRS (Software Requirement Specification),</li><li>SDD (Softwre Design Document),</li><li>BRS (Bussiness Requirement Specification),</li><li>Sow (Statement of Work)</li></ul><p>dokümanlarını birebir karşılayacak bir doküman değil ancak <strong>kesinlikle işinize yarayacaktır</strong>.</p><p>&nbsp;</p><p>Projenin ana şablonunda yer alan başlıklar aşağıdaki gibi. Ancak size tavsiyem Github’a yüklediğim <a href=\"https://github.com/denopas/YazilimProjeYonetimi/blob/master/Yaz%C4%B1l%C4%B1m%20Proje%20%C5%9Eablonu%20v2.0.docx\">şuradaki dokümanı</a> indirerek oradaki detaylar üzerinden projenizi şekillendirmeniz.</p><p><strong>1. Projenin Amacı</strong><br>(Not: 10–12 cümle ile projenin amacı anlatılacak)<br><strong>2. Kısaltmalar</strong><br><strong>3. Projenin Kapsamı</strong><br><strong>4. Projenin Üst Seviye Görünümü</strong><br><strong>5. Fonksiyonel Gereksinimler</strong><br><strong>5.1. Faaliyet ve Süreç ile İlgili Fonksiyonel Gereksinimler</strong><br><strong>5.2. Yazılımla ile İlgili Fonksiyonel Gereksinimler</strong><br><strong>6.Yazılımla ile İlgili Fonksiyonel Olmayan Teknik Gereksinimler</strong><br>(Not: Kullanıcı Sayısı, Erişim Şekli (Web, Mobil), Güvenlik, Gizlilik, Eğitim…)<br><strong>7. Grafik Arayüz Tasarımları</strong><br>(Not: Balsamiq gibi bir araç ile yapılacak uygulamaya ait prototip arayüzler)<br><strong>8. SWOT Analizi</strong><br>(Not: Projenin SWOT analizi yapılacaktır. A) Güçlü yanlarımız: neleri iyi yapabiliriz? Üstün noktalarımız neler? B) Zayıf yanlarımız: Neleri iyileştirmemiz lazım? Rakipler bizden hangi konuda daha iyiler? C) Fırsatlar: Çevremizde ne gibi gelişmeler yaşanıyor? Önümüzdeki fırsatlar neler? D) Tehditler: Önümüzde ne tarz engeller var?)<br><strong>9. Proje Planlama</strong><br><strong>9.1. Proje Metodolojisi</strong><br>(Not: Yazılım projeleri için XP, Scrum, V Model, Şelale kullanılabilir. Projede neden bu yöntemin kullanıldığı 1–2 sayfayı geçmeyecek şekilde anlatılacaktır.)<br><strong>9.2. Proje Ekibi</strong><br>(Not: Projede çalışacak ekibe ait bilgiler yer alacaktır. Analiz-Tasarım-Kodlama-Test-Proje Yönetimi-Ürün Yöneticisi)<br><strong>9.3. Organizasyon Şeması</strong><br>(Not: Proje ekibinin çalışacağı organizasyon şeması burada yer alacaktır.)<br><strong>9.4. Proje Plan Takvimi</strong><br>(Not: Excel veya Microsoft Project benzeri bir araçlar proje takvimi buraya eklenecektir. Projenin ne kadar süreceği ayrıca belirtilecektir. Ya da <a href=\"https://www.ganttproject.biz/\">https://www.ganttproject.biz/</a> kullanılabilir)<br><strong>10. Riskler</strong><br>(Not: Projenin gerçekleştirilmesi sırasında oluşacak idari ve teknik riskler belirlenmelidir. Bu risklerin yönetilmesi için planlama yapılmalıdır.)<br><strong>11. Bütçe ve Kaynaklar</strong><br>(Not: Projenin ilk versiyonunu sahaya sürmek için gerekli olan maliyet nedir? İnsan kaynağı maliyeti de dahil edilmelidir.)<br><strong>12. Sürdürülebilirlik</strong><br>(Not: Proje tamamlanınca sürdürülebilir olması için aylık ne kadar gelire ihtiyaç var? Aylık giderlerimiz neler? Bu gelirin elde edilebilmesi için nasıl bir aksiyon planı yapılabilir?)<br>Örn: Proje tamamlandıktan sonra sürdürülebilir olabilmesi için planlanan iki gelir modeli bulunmaktadır. Reklam, aylık üyelik…</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>Bana; <a href=\"http://denizkilinc.com/\">www.denizkilinc.com</a>, <a href=\"https://www.linkedin.com/in/deniz-kilin%C3%A7-64606622/\">Linkedin</a> üzerinden veya <a href=\"https://twitter.com/denizkilinc\">https://twitter.com/denizkilinc</a> adreslerinden ulaşabilirsiniz.</p><p>Sağlıkla kalın, bir sonraki yazıda görüşmek üzere….</p>", "article_image" : "1641322821880-702588205.jpeg", "user" : { "$oid" : "61d496f745c4f24b6c57513a" }, "likes" : [ { "$oid" : "61d496f745c4f24b6c57513a" } ], "likeCount" : 1, "comments" : [  ], "createdAt" : { "$date" : "2022-01-04T19:00:21.886+0000" }, "slug" : "yazilim-proje-sablonu-basit-ve-herkese-lazim", "__v" : 1 },
{ "_id" : { "$oid" : "61d499a245c4f24b6c5751c2" }, "title" : "Yazılım Geliştirmeye ve Programlamaya Yeni Başlayanlar için Tavsiyeler", "description" : "“Yazılım işine nereden başlamalıyım?”, “Yazılım geliştirme sürecinde bana ne tavsiye edersiniz?”, “Hangi programlama dilini öğrenmeliyim?”, “Hangi kitabı okumalıyım?”, “Kendimi nasıl geliştiririm?”, “Sizce hangi görev benim için daha uygun?”", "content" : "<p>“Yazılım işine nereden başlamalıyım?”, “Yazılım geliştirme sürecinde bana ne tavsiye edersiniz?”, “Hangi programlama dilini öğrenmeliyim?”, “Hangi kitabı okumalıyım?”, “Kendimi nasıl geliştiririm?”, “Sizce hangi görev benim için daha uygun?” gibi sorularla hem akademik kariyerimde (işim gereği) hem de 13 yılı aşkın özel sektör iş yaşamım süresince sürekli karşılaştım.</p><blockquote><p><i>Hatta bu soruları kendime de hep sordum, etrafımda bana yardımcı ustalar aradım durdum :)</i></p></blockquote><p>Yazının başlığı “Yeni Başlayanlar” için olsa da aslında burada değindiğim bir çok konu bu işi yapanlar için <strong>ömür boyu geçerli</strong> diye düşünüyorum. Konuyu 3 kategoride ve alt maddeler halinde toparlamaya çalıştım. Maddeler birbirine girmiş olabilir, kusura bakmayın. Ayrıca farklı bakış açılarına göre yeni kategoriler ve onlarca alt madde de eklenebilir. Ana tavsiye kategorilerim aşağıdaki gibi:</p><ol><li>Sosyal Tavsiyeler</li><li>Genel Teknik Tavsiyeler</li><li>Kodlama Tavsiyeleri</li></ol><p>&nbsp;</p><h2><strong>Sosyal Tavsiyeler</strong></h2><ol><li>Yaptığınız işten <strong>keyif</strong> almaya bakın. Yazılım ve kodlama bir çeşit sanatsal üretim işidir. Aşkla ve şevkle yapılmalıdır. Bana göre bir resim yapmaktan veya bir piyano çalmaktan farksızdır. Keyif almadan bu işi icra etmenize imkan yok. Kişilik olarak bu işe uygunsanız zaten keyif almamanız da imkansız. Eğer bu yazıyı okurken ne dediğimi anlıyor ama ne yapsanız da olmuyorsa, kodlar havada uçuşuyorsa, birisi sizin keyif alma düğmenize tam basamamış demektir. Çözülecek emin olun.</li><li><strong>Elinizi korkak alıştırmayın</strong>. Yanlış yapmaktan korkmayın. Yanlış yapa yapa doğruyu bulacaksınız. Yanlış yapmaktan korkarsanız hem öğrenme süreciniz çok yavaşlar hem de deneme-yanılma yöntemine başvuramayacağınız için sürekli soru sorarak etrafınızdakileri rahatsız etme riskiniz artar.</li><li>Sürekli <strong>tırmalayın</strong> ve <strong>kazıyın</strong>. Gece gündüz demeden araştırın, okuyun, kodlayın ve deneyin. Bir problemi çözemediğinizde ya da bir projeyi bitiremediğinizde uykularınız kaçsın. Problemi çözemeyince hemen pes etmeyin. Stackoverflow ve Quora kullanmaktan çekinmeyin. On binlerce yazılımcı ile aynı yoldan geçiyorsunuz merak etmeyin.</li><li><strong>Konsantrasyonunuzu</strong> en üst seviyede tutun: Kodlama yapmak konsantrasyon gerektiren bir iştir. Odaklanmalısınız, odağınızı dağıtacak ve sizi bölecek her şeyden kaçının. Kodlama aşamasında iletişiminizi olabildiğince kapatın (Telefon, e-posta vb.). <a href=\"https://denizkilinc.com/2013/08/14/yazilimci-konsantrasyonu-beyin-akis-modu-ve-bolunmeler/\">Yazılımcı konsantrasyonu</a> ile ilgili yazıyı okumanızı tavsiye ederim.</li><li><strong>Hayatınızı algoritmik yaşayın</strong>. Aslında sabah kalktığımız andan itibaren karşımıza çıkan her probleme karşı algoritmalar üreterek çözüm buluyoruz. Örneğin sabah kalktığımızda ne giyeceğiz. Mevsim, hava sıcaklığını yağmur yağıp yağmadığı, toplantı olup olmadığı vb. girdileri değerlendiren algoritmayı kafamızda işletir ve ona göre karar veririz. Önemli olan bunun bilincinde olarak hareket etmemiz.</li><li><strong>Gittiğiniz yerlerde kullanılan programlara dikkat edin</strong>. Örneğin bir restorana veya eczaneye gittiğinizde kullandıkları programa göz atın. Kullanıcıya “Nasıl memnun musunuz?”, “Hızlı mı?”, “En beğendiğiniz özelliği nedir?” gibi sorular sorun. Ekran tasarımlarını inceleyin, beğendiniz kısımları not edin.</li><li><strong>1–2 ay önce yazdığınız kodu beğenmeyin</strong>. Beğeniyorsanız bir sakatlık vardır aman dikkat... Ya kendinizi geliştirmeyi (okumayı, araştırmayı, eğitimlere katılmayı) durdurdunuz ya da yazılım geliştirme işinden sıkıldınız demektir.</li><li>Başkasının yazdığı kod üzerinde iş yaparken <strong>sürekli ve yersiz eleştiri yapmaktan kaçının</strong>. Aynı hataları siz de zaman zaman yaptınız. Eleştiri yapmanız gereken ilgili kişiye ulaşarak doğru bir iletişim yöntemi ile kod hakkında tartışabilmeniz çok önemli.</li><li><strong>Sorgulayan</strong>, araştıran bir yapınız olmasa bile yazılım işi sürekli sorgulama ister. Kendinize bu yeteneği kazandırmanız ve gerekli cesareti bulmanız gerekiyor. Sessiz kalırsanız verilen işi yapan durumuna düşebilirsiniz.</li><li><strong>Türkçe</strong> dilini hem söz dizimi hem de anlamsal altyapısı ile düzgün kullanmaya gayret edin. -ki -de/da -nokta/virgülden sonra boşluk bırakmak vb. Yazılı olmayan bu kural, arka planda hayatınızda bilmediğiniz/tahmin etmediğiniz etkilere neden olur.</li><li>Kendinize ait düzgün isimlendirilmiş, temiz, sade, “içi yeterince dolu” <strong>sosyal medya hesaplarınız </strong>(Linkedin, Medium, Twitter) ve bir adet e-posta adresiniz olsun. E-posta işi gerçekten kritik, düzgün bir adrese ek olarak, yazışma adabını da öğrenmeniz gerekiyor (konu, yeterince detay verme, kendinizi tanıtma vb.).</li><li>Grup/ekip olarak yaptığınız yazılım geliştirme projelerinde sürekli <strong>çaycı</strong> veya yancı <strong>olmayın</strong>. Kodu yazan kişinin yanına oturup, anlıyormuş gibi yapmak çok yorucudur. Unutmayın bir yere kadar bu durum idare edilir, ve sizin zaaflarınızı perdeler.</li><li>Mesleğinizle ilgili <strong>teknik ve sosyal etkinliklere </strong>(meetup, hackathon, X-Night) katılmaya çalışın. Motivasyon garantili bu eğitimler hem kişisel gelişiminiz (tecrübe aktarımı) hem de sosyal bir çevre edinmeniz için de oldukça önemli.</li><li><strong>İngilizce</strong> dilini öğrenmekten başka bir şansınız yok. Şahsi fikrim kurslara katılmak faydalı gibi görünse de sürdürülebilir değil. Temel İngilizce dil bilgisini öğrendikten sonra alt yazılı video izleyerek, çeviri yaparak, kitap okuyarak ve yazmaya çalışarak İngilizce öğrenmek bana daha sağlıklı geliyor.</li><li>Hiçbir zaman <strong>OLDUM</strong> <strong>demeyin</strong>. Daha yolun başındasınız. Yazılım ve programlama işinde en büyük risklerden biri her şeyi öğrendiğinizi zannedip, duraklamaya hatta gerilemeye başlamanızdır. Unutmayın hepimiz hayat boyu öğrenciyiz :)</li></ol><p>&nbsp;</p><p><strong>Genel Teknik Tavsiyeler</strong></p><ol><li><strong>Kod yazarken mouse (fare) kullanmamaya özen gösterin</strong>. Kullandığınız kodlama editörünün kısa yollarını iyice öğrenin. Kısa yolları kullanmak kod yazma etkinliğinizi ve kodlama hızınızı arttıracaktır. En önemlisi “sizi havaya sokacaktır ”. Bırakın da kod yazarken klavyenizin tuşuna basışınıza hasta olsunlar :)</li><li><strong>Kağıt kalem</strong> kullanarak analiz etmeyi ve problem çözmeyi öğrenin. Bazen bir problemi çözemediğinizde dakikalarca ekrana bakar ve kod yazamazsınız. Ekrana bakmayı bırakın ve bir kalem kağıt alarak kodunuzu kağıtta yazmaya çalışın (ister şekillerle ister düz yazı ile).</li><li><strong>Not tutmayı</strong> alışkanlık haline getirin. Gencim güzelim unutmam diye düşünmeyin. Not tutmak karşınızdaki kişiyi veya işi ciddiye aldığınızın önemli bir göstergesidir. Ayrıca yapılacaklar (ToDo) ve yapılmayacaklar (Not ToDo) iş listeleriniz olsun. Genlerimizde olsa da kervanı yolda düzmeyin.</li><li><strong>Direk kodlamaya dalmayın</strong>. Özellikle kodlama işi yeni yeni kapmaya başladığınızda içiniz kıpır kıpır olacak hemen kod yazmak isteyeceksiniz, arka planda veritabanı tasarlayacaksınız. Tam da bu noktada dikkatli davranmanız lazım. Önce problemi anlayın, analiz edin, doğru anlayıp anlamadığınız ile ilgili el sıkışma yöntemi bulun. Daha sonra tasarıma ve kodlamaya geçin.</li><li>Yazılım ve programlama üzerine bol bol kitap, dergi ve makale <strong>okuyun</strong>. Örneğin <strong>Clean Code (Temiz Kod) </strong>kitabı mutlaka okumanız gereken bir kitap ve size nasıl iyi kod yazabileceğinizi, kötü yazılmış bir kodu iyi bir koda nasıl dönüştürebileceğinizi öğretecek. Kitapla ilgili</li></ol><p><a href=\"https://medium.com/u/8b525bb5a9ad?source=post_page-----fdd33a02361f-----------------------------------\">Büşra Uzun</a></p><ol><li>’un Türkçe notlarına <a href=\"http://busrauzun.com/clean-code-kitabindan-notlar.html\">buradan</a> ulaşabilirsiniz.</li><li><strong>İyi derecede debug (hata ayıklama) etmeyi öğrenin</strong>. Bundan sonraki hayatınız iyi kod yazmaya çalışmakla ama yazamamakla (örneğin: zaman baskısı nedeniyle) ve iyi niyetle yazılmaya çalışıldığı halde kötü yazılan kodları debug etmekle geçebilir.</li><li>Mutlaka <strong>en az 2 tane programlama dilinde uzman</strong> olacak şekilde kendinizi yetiştirin (Şahsi fikrim Python ve C# olması yönünde). Bunları öğrendikten sonra her 2 senede bir yeni bir programlama dili öğrenmeye çalışın (Uzman olmanıza gerek yok). Ancak aynı anda 2 dili öğrenmeye çalışmayın. Aslında en güzel programlama dilinin temel tasarımını ve yapısını öğrenmeniz ancak hepimiz bu şansı elde edemeyebiliriz.</li><li>En ince ayrıntısına kadar <strong>Nesne Yönelimli Programlama (Object Oriented Programming) </strong>yaklaşımını/paradigmasını özümseyin ve <strong>içselleştirin</strong>. Temel kavramlar şöyle: sınıf (class), nesne (object), soyutlama (abstraction), kalıtım (inheritance), kapsülleme (encapsulation), bilgi saklama (information hiding), çok biçimlilik (polymorphism).</li><li>Yazılım geliştirme yaşam döngülerinin / çevrim modellerinin (<strong>SDLC = Software Development Life Cycles</strong>) ne olduğunu ve temel aşamalarını mutlaka öğrenin. “Çağlayan modelden çevik modele geçtik iyi oldu” diyenlerin ne demek istediğini anlayın. Hatta bir gün, çevik yazılım geliştirme gerçekten iyi mi diye soran ustalar olursa onlara da kulak verin.</li><li>Kod yapılandırmasının <strong>(refactoring)</strong> ne olduğunu, sürecini ve nasıl yapıldığını öğrenin. İlk başta size ve ekibinize riskli bir iş gibi görünebilir. Mevcut durumun problemlerini/kaybını sayılarla ortaya koyarsanız ve bu problemleri çözdüğünüzde kaç para kazandırabileceğinizi doğru anlatırsanız (hele bir de yeni teknoloji vs. de işin içinde varsa) mutlaka destek alacaksınız…</li><li><strong>Kodunuzu çöpe atmaktan çekinmeyin</strong>. Gerçekten içinize sinmiyorsa o kod çöpe gitmeli ve baştan yazmalısınız. Baktınız kod yapılandırması süreci de işe yaramıyor, bu kararı bir şekilde vermelisiniz. Merak etmeyin er ya da geç bu durum gerçekleşecek. Ne kadar hızlı yaparsanız sizin için o kadar iyi olacaktır.</li><li>Yazılım geliştirme işinin en önemli çıktısı yazılım ürünüdür. Yazılım ürünü çıkarabilmek için bir<strong> yazılım projesinin</strong> ne olduğunu bilmek gerekir. Bir projenin başı, sonu, gereksinimleri, tasarım kısıtları, dili, teknolojisi vs. belli olmalıdır. Özellikle işe yeni başlayan arkadaşlar o kadar fazla konu/dil/teknoloji ile aynı anda uğraşırlar ki hiç bir proje ortaya çıkmaz ve günün sonunda motivasyon düşer. Basit bir hesap makinesi, sayı tahmin oyunu, kütüphane uygulaması veya mobil bir görev hatırlatıcısı çok güzel birer proje olabilir, konunun detayı tamamen size kalmış. Yok bana yetmez diyorsanız ve aldığınız ödevler de sizi kesmiyorsa,</li></ol><p><a href=\"https://medium.com/u/3be29aeb6524?source=post_page-----fdd33a02361f-----------------------------------\">Ahmet Emre Aladağ</a></p><ol><li>arkadaşımızın hasta olduğum ve öğrencilerimle paylaştığım proje listesinin linkini <a href=\"https://www.emrealadag.com/proje-fikirleri-tum-liste/\">şuraya</a> bırakıyorum.</li><li>Geliştirdiğimiz projeleri sergileyebileceğimiz, paylaşabileceğimiz ve ortak proje geliştirme süreci yürüterek, aynı zamanda kaynak kod kontrolü yapabileceğimiz <strong>GitHub</strong> ortamında mutlaka düzgün bir hesabımızın olması gerekiyor. Bırakın CV’niz yerine GitHub hesabınızdaki projeleriniz sizi anlatsın.</li><li>Veri yapıları, algoritma analizi, işletim sistemleri konuları/dersleri ne işime yarayacak? bunları bırak da bize programlama öğret diyen zihniyetin esiri olmayın. İşimizi -mış gibi yapmakla doğru yapmak arasındaki farkın detayları bu derslerde yer alıyor.</li></ol><p><strong>Kodlama Tavsiyeleri</strong></p><ol><li>İyi kod, okunabilirliği ve bakımı kolay olan basit koddur. <strong>Basit kodlar</strong> yazmaya çalışın. Bu noktada hayatınızı kolaylaştıracak araçlar/yöntemler nesne yönelimli programlama yaklaşımını öğrenmeniz ve SOLID yazılım geliştirme prensiplerini kullanmanız olacaktır. <strong>S</strong>ingle Responsibility, <strong>O</strong>pen-Close , <strong>L</strong>iskov Substitution, <strong>I</strong>nterface Segregation , <strong>D</strong>ependency Inversion. Bana sorarsanız iyice öğrenmeniz gereken en temel iki prensip coupling (düşük olsun) ve cohesion (yükseği makbul). Diğer prensiplerin kayda değer bir kısmı bunların etrafında dönüyor sanki :)</li><li>Kendinize ait <strong>kodlama isimlendirme standardınız</strong> olsun veya bu konu ile ilgili mutlaka ne yapmanız gerektiğini öğrenin. Örneğin değişkenleri nasıl isimlendireceksiniz (Pascal, Camel isimlendirme stilleri vb.). değişkenlerinizin, sabitlerinizin, fonksiyonlarınızın, sınıflarınızın, nesnelerinizin vb. tüm programlama elemanlarının isimleri anlaşılır olmalı. Bu isimler ne çok uzun ne de çok kısa olmalı. O kadar çok isimlendirme yapıyoruz ki bu konuyu gerçekten kafamıza takmamız lazım.</li><li>Kod girintileriniz muntazam olsun (<strong>Code indentation</strong>). Günümüz modern IDE’leri girintileri bozmanıza izin vermese de bunu becerebilen arkadaşlar ve kod parçaları gördüm :)</li><li>Aritmetik operatörler ve atama operatörlerinden önce ve sonra mutlaka birer boşluk karakteri kullanın. Ne olur alıştırın kendinizi, sizden sonra kodu okuyanları üzmeyin :)</li><li>Gerektiği kadar <strong>yorum satırı</strong> kullanın (code comments). Eskiden yorum satırı kullanımına karşı değildim ancak zaman içerisinde yorum satırlarının aslında kötü tasarımlarımı örtmek için kullandığımı fark ettim. Bırakın kod satırları kendi kendilerini anlatsın, sizin onları ayrıca anlatmanıza gerek kalmasın.</li><li><strong>İç içe “if deyimi” (gereksiz koşullar) kullanımlarından kaçının.</strong> İç içe 2 veya 3 tane if deyimi kullandıysanız veya bu durum herhangi bir programda karşınıza çıkarsa mutlaka kodunuzu değiştirin veya baştan yazın. Örneğin fonksiyonlarda erken çıkış (early return)tekniğini kullanarak ya da daha ince nesne yönelimli programlama teknikleri kullanarak bu işin üstesinden gelebilirsiniz.</li><li><strong>İleride kullanırım belki diye kod parçaları eklemeyin.</strong> Ya kullanmazsanız ne olacak? Hele bir de isimlendirme standartlarınız yoksa, temiz kod yazmayı bilmiyorsanız, projeniz ne işe yaradığını bilmediğiniz kod çöplüğüne dönmeye başlayacak.</li><li><strong>Metotlarınızın</strong> ve fonksiyonlarınızın içerikleri <strong>uzun olmasın</strong>. Sadece bir işi yapan fonksiyonlarınız olsun ve sadece (ama sadece) o işi yapsın. Aslında yazılım tasarım prensiplerindeki tek sorumluluk (single responsibility) prensibi içselleştirilmesi gereken önemli bir konu.</li><li><strong>Tekrar eden kod parçası</strong> yazmaktan, kopyalayıp yapıştırmaktan <strong>kaçının</strong>. Tekrar eden kodları avantajınıza yani tekrar kullanılabilir koda dönüştürmeniz mümkün. Bunun için onlarca yöntem bulabilirsiniz. Programlama dili zorunluluğuna göre yordamsal ya da nesne yönelimli programlama ile rahatça çözebileceğiniz bir <strong>anti-pattern</strong>.</li><li>Anti-pattern demişken buradan yürüyelim :) Yazılım geliştirme sürecinde mükemmeli nasıl yakalarım diye düşünmeden önce belki de uzak durmanız gereken yaklaşımları öğrenmek, süreci sindirmenizi sağlayabilir. Örneğin, altın çekiç (golden hammer) anti-pattern’i der ki “Elinde sadece çekiç olan birisine tüm problemler çivi gibi görünür”. Maalesef her yazılımcı bu anti-pattern’i yaşamında bir dönem tecrübe eder. Bunun dışında god object, spaghetti kodlama ve lasagna kodlama gibi farklı anti-pattern’ler de mevcuttur.</li><li><strong>Benim yazdığım kodda hata çıkmaz demeyin</strong>, kodu yazdıktan sonra tekrar tekrar farklı parametrelerle test etmeye çalışın. Hata yapmak için kod yazmadığınızdan dolayı kendi hatanızı bulmak elbette kolay olmayacaktır :) Yazılımcı olarak uygulayabileceğimiz en etkili yöntemlerden birisi yazdığınız kodlar için <strong>birim testi (unit test) </strong>kodları<strong> </strong>geliştirmek olacaktır. Ayrıca test ekipleri tarafından gerçekleştirilen ve <strong>beyaz kutu (white box</strong>) test tekniği ile tasarlanan <strong>kod kapsama (code coverage)</strong> testleri de bu noktada hayat kurtarıcıdır.</li></ol><p>Sizlerden alacağım yorumlarla yazıyı genişletmeyi çok isterim.</p><p>Sevgiler...</p><p><br>&nbsp;</p>", "article_image" : "1641322914272-60784690.jpeg", "user" : { "$oid" : "61d496f745c4f24b6c57513a" }, "likes" : [ { "$oid" : "61d496f745c4f24b6c57513a" }, { "$oid" : "61d4973045c4f24b6c575158" }, { "$oid" : "61d4971b45c4f24b6c575149" }, { "$oid" : "61d4969245c4f24b6c575114" }, { "$oid" : "61d496ac45c4f24b6c575123" } ], "likeCount" : 5, "comments" : [ { "$oid" : "61d49b2345c4f24b6c575282" }, { "$oid" : "61d49ba445c4f24b6c575330" }, { "$oid" : "61d49c0a45c4f24b6c575407" }, { "$oid" : "61d49c4145c4f24b6c57545f" }, { "$oid" : "61d49cbf45c4f24b6c5754f6" } ], "createdAt" : { "$date" : "2022-01-04T19:01:54.274+0000" }, "slug" : "yazilim-gelistirmeye-ve-programlamaya-yeni-baslayanlar-icin-tavsiyeler", "__v" : 10 },
{ "_id" : { "$oid" : "61d49a8945c4f24b6c5751ff" }, "title" : "Kozmik Enflasyon Teorisi ve Büyük Patlama: Evrenin Başlangıcında Gerçekte Ne Oldu?", "description" : "Büyük Patlama\" Dediğinizde 2 Ayrı Şeyi Kastediyorsunuz. Bunlardan Sadece Biri Doğru!", "content" : "<blockquote><p><i>Bu teoriler, evrendeki tüm maddenin uzak geçmişteki belirli bir anda oluşmuş olduğu hipotezine dayanıyordu. -Fred Hoyle</i></p></blockquote><p>Evren'in nasıl oluştuğunu bilimsel olarak düşünecek olursanız, bu uçsuz bucaksız Evren'de gördüğümüz her şeyin başlangıcını açıklayan bir teori var: \"Big Bang\", yani \"Büyük Patlama\". Ancak Büyük Patlama'nın tam olarak ne olduğu konusunda herkes aynı fikirde değil. Hele ki ara ara çıkan ve Büyük Patlama'nın hiç gerçekleşmediğini öne süren haberleri görmek kafanızı karıştırıyor olabilir.<a href=\"https://evrimagaci.org/kozmik-enflasyon-teorisi-ve-buyuk-patlama-evrenin-baslangicinda-gercekte-ne-oldu-11300#qref-1\">[1]</a> Peki Büyük Patlama'nın hiç yaşanmamış olma ihtimali mantıklı mı? Eğer öyleyse bu, kozmoloji ve Evren algımız açısından ne anlama geliyor?</p><h2><strong>Evren'in Genişlediği Nasıl Keşfedildi?</strong></h2><p>Evren'in genişlediğini nasıl keşfettiğimizi, dolayısıyla bir başlangıcı olması gerektiği fikrinin nasıl doğduğunu anlamak için 100 yıl geriye, spesifik bir gök cismi grubunu, gökyüzümüzdeki soluk sarmal ve eliptik bulutsuları detaylıca gözlemeye karar verdiğimiz ilk zamanlara geri dönelim.</p><p><img src=\"https://cdn.evrimagaci.org/h3ilKc9aJ6DMuDg28_YaM5ECXiQ=/825x0/filters:no_upscale():format(webp)/evrimagaci.org%2Fpublic%2Fcontent_media%2Fde48ccbddb1eeb9ab652aa696439e0a3.jpeg\" alt=\"\"></p><p>ESA/Hubble &amp; NASA</p><p>Bugün bu fotoğraftaki cisimlere bakan birinin <i>\"Bunların her biri bir galaksi!\"</i> demesi kolay... Ama bir asır önce bu, bu bilgi o kadar da net değildi. O zamanlar teleskoplarımız, bu cisimleri oluşturan yıldızları tek tek gösterecek kadar iyi değildi (birkaç görsel aşağıda, eski bir galaksi fotoğrafını görebilirsiniz). Bu yüzden onların bir tür \"bulutsu\" olduğu düşünülüyordu. Fakat gözlediğimiz bu gök cisimleri hakkında son derece tuhaf olan bir şey vardı: hızları.</p><p>Bu Reklamı Kapat</p><p>&nbsp;</p><p><img src=\"https://cdn.evrimagaci.org/t5KmWpyOWdfp67TA5DwrB9zFlfQ=/825x0/filters:no_upscale():format(webp)/evrimagaci.org%2Fpublic%2Fcontent_media%2F95efe9ec7778f357a595aefa208a0ddb.png\" alt=\"\"></p><p><a href=\"http://www.ezizka.net/astronomy/lessons/topicslesson08/topic01lesson08.htm\">Ezizka</a></p><p>Her elementin kendi karakteristik spektrumu, yani ya absorbe ettiği ya da yaydığı bir dizi dalgaboyu vardır ve bu spektrum, belirli bir dalgaboyu setinde sabitlenmiştir. Örneğin hidrojen her zaman belirli bir atomik enerji geçişine karşılık gelen 656, 486, 434 ve 410 nanometrelerde çizgiler gösterir.</p><p><a href=\"https://evrimagaci.org/kategori/fiziksel-kozmoloji-262\"><strong>Fiziksel Kozmoloji ile ilgili diğer içerikler ›</strong></a></p><ul><li><a href=\"https://evrimagaci.org/sifir-kelvinin-altina-inmek-mutlak-sifir-olarak-bilinen-sicaklik-gercekten-mutlak-mi-1811\">Sıfır Kelvin'in Altına İnmek: Mutlak Sıfır Olarak Bilinen Sıcaklık, Gerçekten \"Mutlak\" mı?</a></li><li><a href=\"https://evrimagaci.org/evrenin-yasi-138-milyar-yil-iken-capi-nasil-93-milyar-isik-yili-olabilir-2954\">Evrenin Yaşı 13.8 Milyar Yıl İken Çapı Nasıl 93 Milyar Işık Yılı Olabilir?</a></li><li><a href=\"https://evrimagaci.org/kozmik-latte-evrenin-rengi-ve-renklerin-fizigi-8976\">Kozmik Latte: Evrenin Rengi ve Renklerin Fiziği</a></li></ul><p>&nbsp;</p><p>Ama gözlediğimiz ilk galaksi fotoğrafındaki spiraller ve eliptikler, soğurma çizgilerinin <i>hepsini </i>gösteriyordu; fakat bunların hepsi, normalde olması gerekenden <i>kaymış </i>haldeydi.</p><p><img src=\"https://cdn.evrimagaci.org/MAqJAQbZbCJClgLNzBjZqm1oIsU=/825x0/filters:no_upscale():format(webp)/evrimagaci.org%2Fpublic%2Fcontent_media%2Fdd8b4be724c59aace344714639a79c66.png\" alt=\"\"></p><p><a href=\"http://www.webexhibits.org/causesofcolor/18A.html\">WebExhibits</a></p><p>Bu olayın <a href=\"https://evrimagaci.org/parsimoni-ilkesi-tutumluluk-ilkesi-alternatif-aciklamalar-arasindan-neden-daha-basit-olanlari-tercih-etmelisiniz-11282\">en basit açıklaması</a>, bu cisimlerin ya bize doğru ya da bizden uzağa doğru hızla hareket etmesiydi; aksi takdirde, daha karmaşık bir açıklama olarak, bu bulutsuların <i>her birinin</i> doğasında var olan, hiç bilmediğimiz yeni bir tür element veya henüz keşfetmediğimiz <a href=\"https://evrimagaci.org/doganin-henuz-bilmedigimiz-5-temel-kuvvetinin-izleri-kuantum-parcaciginin-tuhaf-davranisi-mevcut-fizik-anlayisimizi-degistirebilir-10341\">yeni bir <i>fizik türü</i></a><i> </i>olduğunu varsaymamız gerekecekti.</p><p>&nbsp;</p><p>Öte yandan, bu gök cisimleri <i>bize göre</i> uzaklaşacak biçimde hareket ediyorsa, o zaman bu çizgilerde gözlediğimiz kayma da tamamen anlamlı olurdu. Çünkü tıpkı bir polis arabasından ambulansa kadar her türlü ses kaynağının bizden uzaklaşırken veya bize doğru hareket ederken ses perdesinin değişmesi gibi, uzaktaki bir cismin de bizden uzağa veya bize doğru hareket etmesine bağlı olarak <a href=\"https://evrimagaci.org/isikta-doppler-etkisi-kirmiziya-kayma-nedir-maviye-kayma-nedir-uzak-mesafeler-kat-eden-isik-neden-renk-degistirir-9593\">ışık dalgaboyu değişecektir.</a> Bize doğru hareket ederse, ışık maviye doğru; bizden uzaklaşırsa da kırmızıya doğru kayacaktır. 20. yüzyılın başında Vesto Slipher, uzaydaki spiral galaksilerin birçoğunun kırmızıya kaydığını ve bu rengin bilinen Evren'deki her şeyden daha hızlı hareket ettiklerini gösterecek kadar çok değiştiğini fark etti.</p><p>&nbsp;</p><p>&nbsp;</p><p><img src=\"https://cdn.evrimagaci.org/1eSiJSiZTsTMhKIwm2JnqIxK0xY=/825x0/filters:no_upscale():format(webp)/evrimagaci.org%2Fpublic%2Fcontent_media%2F2017d9d5ce40907c120b5c30044e8bbc.png\" alt=\"\"></p><p><a href=\"http://www.gizmag.com/hubble-spitzer-expansion-universe-redshift-cepheid/24457/pictures#12\">NASA</a></p><p>Ancak bu yapboz parçaları, ilk olarak 1920'lerde bir araya gelmeye başladı. <a href=\"https://evrimagaci.org/hubble-teleskobu-ne-cekti-yaratilis-sutunlarindan-macellan-bulutuna-3193\">Ünlü teleskoba</a> adını veren Edwin Hubble, bu spiral galaksilerde yaşanacak \"alevlenmeleri\" gözlemleyip, <a href=\"https://evrimagaci.org/supernova-nedir-yildizlar-neden-patliyor-ve-bir-sonraki-nesil-yildizlar-yakitini-nereden-buluyor-4244\">nova gibi olayları</a> görmek istiyordu. Şaşırtıcı bir şekilde, Andromeda Galaksisi'ne bakarken birini görmeyi başardı. Sonra ikinciyi... Sonra da üçüncüyü... Ama sonra, dördüncü novayı da <i>birinciyle aynı konumda</i> gözlemledi. İşte o anda bunun bir nova değil de, bir \"değişken yıldız\" olduğunu anladı. Değişken yıldızlar, parlaklıkları zaman içinde değişen yıldız türleridir. Bu tür değişken yıldızlar o zamanlar da bilindiğinden, Hubble, gözlediği cismin kendi galaksimizin çok dışındaki bir yıldız olduğu sonucuna varabilmişti. Bu sayede, o yıldızın uzaklığını da hesaplayabilmişti.</p><p><img src=\"https://cdn.evrimagaci.org/OPXIEh3aOBNseV2fvjJXjwxbuQo=/825x0/filters:no_upscale():format(webp)/evrimagaci.org%2Fpublic%2Fcontent_media%2Fea9d42eae93d884dda38acfcdd637d4f.jpeg\" alt=\"Eski bir galaksi fotoğrafı\"></p><p>Eski bir galaksi fotoğrafı<a href=\"https://obs.carnegiescience.edu/PAST/m31var\">Carnegie Observatories</a></p><p>Elbette, bu spiral galaksilerden birinde değişken yıldızların olduğunu keşfettiğinde, Hubble bununla yetinmedi. Düzinelerce galaksinin mesafelerini ölçmeye devam etti ve elde ettiği verileri Slipher'ın hız verileriyle birleştirdiğinde, olağanüstü bir şey keşfetti: <strong>Bir galaksi ne kadar uzaksa, bizden </strong><i><strong>ortalamada </strong></i><strong>o kadar hızlı uzaklaşıyordu!</strong></p><p>İşte \"Genişleyen Evren\" hipotezi, bu şekilde doğdu.</p><p><img src=\"https://cdn.evrimagaci.org/N-nYKaQXcl8J7adJkBx5PIsX17o=/825x0/filters:no_upscale():format(webp)/evrimagaci.org%2Fpublic%2Fcontent_media%2Ffef24998bc87c5e0885490fa0e89403c.png\" alt=\"\"></p><p>Robert P. Kirshner ve Edwin Hubble</p><h2><strong>Zamanda Sürekli Geriye Gidersek Ne Olur?</strong></h2><p>Genel Görelilik bağlamında, farklı konumlarda madde veya radyasyonla dolu uzay-zamanlar (ki bunlar, bizimki gibi uzay-zamanlardır), zaman içinde statik kalma konusunda pek iyi değildirler. Bu yüzden içerdikleri enerji miktarına bağlı olarak ya genişler ya da daralırlar. <strong>Gözlemlediğimiz şey, Evren'imizin geçmişte daha yoğun olan bir durumdan bugüne dek genişlemeye devam ettiğidir.</strong></p><p>Işığın (radyasyonun) sahip olduğu enerji miktarı dalga boyuna da bağlı olduğundan, bu, <i>aynı zamanda,</i> uzay geçmişte <i>daha küçükse daha sıcak </i>olması gerektiğini, dolayısıyla <i>daha çok enerjiye</i> sahip olması gerektiğini de gösterir.</p><p>&nbsp;</p><p>&nbsp;</p><p><img src=\"https://cdn.evrimagaci.org/RlRchzsybKTEdVC-yovyxkloXcw=/825x0/filters:no_upscale():format(webp)/evrimagaci.org%2Fpublic%2Fcontent_media%2F2da4e56c01a95d79ba0f7068b042466d.jpeg\" alt=\"\"></p><p>Bunun tam tersini de hayal edelim: Örneğin Evren'in günümüzdeki gibi var olduğunu, ama geçmişe gittikçe daha çok ısındığını ve küçüldüğünü düşünün. Zamanda yeterince geriye gitseydik Evren nasıl görünürdü?</p><ul><li>O kadar sıcak ve yoğun olurdu ki atomlar oluşamazdı. Başlangıçta her şey, sıcak ve iyonize bir plazma olurdu.</li><li>Bunun öncesinde bile atom çekirdeğinin oluşması mümkün olmazdı; protonlar ve nötronlar parçalara ayrılarak hidrojenden başka element içermeyen bir serbest parçacık denizi yaratırdı.</li><li>Bundan önce de, <a href=\"https://evrimagaci.org/maddeantimadde-asimetrisi-neredeyse-tamamen-maddeden-olusan-evrenimizde-antimadde-nereye-kaybolmus-olabilir-10269\">madde ve antimadde</a> kendiliğinden çiftler halinde yaratılarak Evren'de bilinen tüm (ve potansiyel olarak şimdiye kadar keşfedilmemiş bazı parçacıkların) ortaya çıkmasına neden olurdu.</li><li>Nihayet, zamanda <i>iyice geriye gidersek</i>, cisimlerin rastgele bir şekilde, belki de sonsuz miktarda sıcak ve yoğun olduğunu görür ve bir <strong>tekillik </strong>noktasına ulaşırdık: Uzay ve zaman, tek bir noktaya sıkışmış hâlde bulunurdu.</li></ul><p>Her şeyin bir \"kozmik yumurtadan\", \"ilkel bir atomdan\" veya \"rasgele sıcak, yoğun bir durumdan\" ortaya çıktığı fikri, bugün \"<strong>Büyük Patlama</strong>\" olarak bildiğimiz şeydir.</p><h2><strong>Kozmik Enflasyon Nedir?</strong></h2><p>Ancak bu, Büyük Patlama'nın <i>orijinal </i>tanımıydı. Bu fikir ilk ortaya atıldığından beri Evren hakkında çok şey öğrendik. En önemlisi, Evren'in madde ve radyasyon dışında, <strong>kendisine içkin bir miktar enerji</strong> (veya bu enerjinin eş anlamlıları olan \"<a href=\"https://evrimagaci.org/karanlik-enerji-nedir-karanlik-enerjinin-ne-oldugunu-neden-hala-bilmiyoruz-9629\">karanlık enerji</a>\", \"kozmolojik sabit\" veya \"vakum enerjisi\") içerdiğini öğrendik.</p><p>Günümüzde nispeten <i>küçük </i>bir miktarını içeriyor olsa da, geçmişte Evren bu enerjinin muazzam derecede <i>büyük </i>bir miktarını içeriyordu.</p><p>&nbsp;</p><p><img src=\"https://cdn.evrimagaci.org/Ozg_FwzWrjkDxd5RCCD7Q3c3V4s=/825x0/filters:no_upscale():format(webp)/evrimagaci.org%2Fpublic%2Fcontent_media%2F210673845e12c0462843954e3fc65aab.png\" alt=\"Kozmik yapının kuantum kökenleri\"></p><p>Kozmik yapının kuantum kökenleri<a href=\"https://inspirehep.net/literature/871105\">Inspire</a></p><p>Evet, doğru: Madde ve radyasyon tarafından domine edilmeden önce, Evren'e, ona içkin bu enerji miktarı hakimdi. Bu teori, ilk olarak 1970'lerin sonlarında, 1980'lerin başlarında ortaya atıldı ve 1990'ların başında gözlemsel olarak doğrulandı. <strong>Kozmolojik Enflasyon </strong>(veya <strong>Enflasyonist Evren</strong>) denildiğinde bahsedilen şey budur: Evren'de madde veya radyasyonun değil, uzayın kendisine içkin bir enerjinin hakim olduğu bir zaman...</p><p>Ve vakum enerjisi (veya bir diğer tanımıyla \"enflasyon\"un) hakim olduğu evrenler, madde ve radyasyonun hakim olduğu evrenlerden farklı gelişir.</p><p><img src=\"https://cdn.evrimagaci.org/gvSVJRbp4jq8fZWjf37YwDWISas=/825x0/filters:no_upscale():format(webp)/evrimagaci.org%2Fpublic%2Fcontent_media%2Feb2a8b4955b2b34035931258a1203072.png\" alt=\"Evren'in farklı unsurlar tarafından domine edilmesi durumunda nasıl büyüyeceğini gösteren grafikler.\"></p><p>Evren'in farklı unsurlar tarafından domine edilmesi durumunda nasıl büyüyeceğini gösteren grafikler.<a href=\"https://medium.com/starts-with-a-bang/the-two-big-bangs-1493194f5cd9\">Medium</a></p><p>Elbette, bu evrenler yalnızca ayrıntılarda farklılık gösteriyormuş gibi görünebilir, ancak hepsi belirli bir başlangıç noktasından belirli bir oranda genişler.</p><p>Yoksa öyle değil mi? Haydi, şu \"başlangıç\"a biraz daha yakından bakalım.</p><h2><strong>Başlangıçta </strong><i><strong>Gerçekte </strong></i><strong>Ne Oldu?</strong></h2><p>Maddenin veya radyasyonun hakim olduğu bir evren, gerçekten de uzay ve zamanın ilk belirdiği an olan \"tekillik\" noktasından oluşmaya başlar. <strong>Enflasyonist bir evren içinse böyle bir an yoktur.</strong></p><p>&nbsp;</p><p>&nbsp;</p><p><img src=\"https://cdn.evrimagaci.org/h5JMy7g-FCAzcoCN4FM2V8Rvq9w=/825x0/filters:no_upscale():format(webp)/evrimagaci.org%2Fpublic%2Fcontent_media%2F4e1ae4d3df7b56f92db3d5cab1788034.png\" alt=\"Mavi ve kırmızı çizgiler, &quot;geleneksel&quot; Büyük Patlama senaryosunu gösterir. Uzay-zaman da dahil her şey t=0 anında başlar. Ama enflasyon senaryosunda (sarı ile gösterilmekte), hiçbir zaman uzayın tekil bir noktaya indirgendiği bir tekilliğe ulaşamayız. Bunun yerine, geçmişe gittikçe rastgele bir şekilde küçülebilir; ama zaman, geçmişe doğru sonsuza dek gider.\"></p><p>Mavi ve kırmızı çizgiler, \"geleneksel\" Büyük Patlama senaryosunu gösterir. Uzay-zaman da dahil her şey t=0 anında başlar. Ama enflasyon senaryosunda (sarı ile gösterilmekte), hiçbir zaman uzayın tekil bir noktaya indirgendiği bir tekilliğe ulaşamayız. Bunun yerine, geçmişe gittikçe rastgele bir şekilde küçülebilir; ama zaman, geçmişe doğru sonsuza dek gider.<a href=\"https://medium.com/starts-with-a-bang/the-two-big-bangs-1493194f5cd9\">Medium</a></p><p>Bir başka deyişle, sözünü ettiğimiz son nokta, yani <strong>uzay-zamanın ilk belirdiği bir ânın var olduğu fikri, başlangıcında kozmik enflasyon dönemi bulunan evrenlerde, Büyük Patlama'nın bir aşaması olmak zorunda </strong><i><strong>değildir.</strong></i></p><h2><strong>Büyük Patlama Derken Neyi Kastediyoruz?</strong></h2><p>Kozmologlar, yani Evren'in kökeni ve gelişimiyle ilgilenen bir astrofizik alt dalında uzman olan kişiler, Büyük Patlama hakkında konuşurken bu iki şeyden birini kastederler:</p><ol><li><a href=\"https://evrimagaci.org/evren-nedir-evren-ne-kadar-buyuk-gozlenebilir-ve-gozlenemeyen-evrenin-toplam-buyuklugu-ne-kadar-5137\">Gözlenebilir Evren'imizin</a> oluştuğu, genişleyen, yavaşlayan, soğuyan ve elementleri, atomları, yıldızları, molekülleri, gezegenleri ve nihayetinde bizi meydana getiren sıcak, yoğun, genişleyen süreç/durum.</li><li>Uzay ve zamanın ortaya çıktığı ânı ifade eden başlangıçtaki tekillik, ilk ân.</li></ol><p>Tek sorun şu: <strong>Bu iki açıklama 1960'larda birbirinin yerine kullanılabiliyordu; ama durum artık böyle değil: </strong>İlk açıklama -sıcak, yoğun, genişleyen durum- hala \"Büyük Patlama\" olarak anlaşılsa da, ikincisi artık böyle bir anlama sahip değil.</p><p>Aslına bakarsanız, uzay ve zamanın nereden geldiği sorusu söz konusu olduğunda, bu konudaki tartışmaların halen sürdüğünü söylememiz gerekiyor: Örneğin yazı başında sözünü ettiğimiz ve bir başlangıcın olmadığını söyleyen <a href=\"https://phys.org/news/2015-02-big-quantum-equation-universe.html\">bu son makale</a>, bu konudaki tartışma okyanusundaki tek bir damladan ibaret.</p><h2><strong>Tüm Bunlar Ne Anlama Geliyor?</strong></h2><p>Tüm bunlardan öğrenmeniz gereken en önemli şey ne mi? <strong>Büyük Patlama'nın, Evren'de gördüğümüz her şeyin nereden geldiğini ifade eden bir terim olmasına rağmen, artık \"Evren'in başlangıcı\" olmadığını anlamak.</strong> Enflasyonist bir evrende geriye gittikçe, var olan her şeyin kökeninin tam olarak ne olduğunun incelikleri konusunda tartışacak birçok şey var.</p><p>Ama özetle, <i>\"Bir Büyük Patlama yaşandı mı?\"</i> diye soruyorsanız... \"Büyük Patlama\" terimini kullanırken, yukarıda verdiğimiz iki anlamdan ilkini kastediyorsanız, <i>evet</i>, kesinlikle yaşandı! Evren'imiz başta çok sıcak ve çok ufaktı; genişledi, soğudu ve bu sayede elementler, atomlar, yıldızlar ve geri kalan her şey doğdu. Ama \"Büyük Patlama\" derken ikinci anlamı kastediyorsanız, yani \"Büyük Patlama\" sözcüğünün Evren'in <i>başlangıcı </i>olduğunu iddia edecekseniz, ondan daha geride hiçbir şey olmadığını söyleyecekseniz, \"Büyük Patlama\" teriminin ne anlama geldiğini <i>gerçekten </i>iyi düşünmelisiniz. Enflasyon Teorisi'nde <i>istediğimiz kadar </i>ve pratikte <i>sonsuza dek </i>geriye gidebiliriz - Büyük Patlama'dan da öncesine kadar (en son grafikte sarı çizgi sola, yani geçmişe doğru sonsuza dek gider ve asla 0 ânına ulaşmaz).</p><p>Büyük Patlama sözcüğünü bu eski anlamıyla kullanarak hataya düşen tek kişi siz olmayacaksınız elbette; ama <i>yalnız olmamak</i> yerine, <i>haklı </i>olmayı tercih etmez miydiniz?</p>", "article_image" : "1641323145797-81020384.png", "user" : { "$oid" : "61d4973045c4f24b6c575158" }, "likes" : [ { "$oid" : "61d4973045c4f24b6c575158" }, { "$oid" : "61d4969245c4f24b6c575114" }, { "$oid" : "61d496f745c4f24b6c57513a" }, { "$oid" : "61d4971b45c4f24b6c575149" } ], "likeCount" : 4, "comments" : [ { "$oid" : "61d49b4045c4f24b6c5752e2" } ], "createdAt" : { "$date" : "2022-01-04T19:05:45.800+0000" }, "slug" : "kozmik-enflasyon-teorisi-ve-buyuk-patlama-evrenin-baslangicinda-gercekte-ne-oldu", "__v" : 5 },
{ "_id" : { "$oid" : "61d49afa45c4f24b6c57523a" }, "title" : "Making $700 a Month as a Student", "description" : "No surveys, blogs or courses", "content" : "<p>A couple of years ago me and my friend were brainstorming ideas for a side hustle to earn us some extra money over the summer break. After a few days of pitching ideas back and forth, we had decided to start a side hustle based around <strong>Online Reputation Management</strong>.</p><p>ORM is about using methods to influence an individuals or businesses reputation.</p><p>For the business, we targeted restaurants in our local area and decided we would boost their “Google My Business” reviews. For this to work, we will first need a way to gather reviews and filter the negative reviews.</p><p>&nbsp;</p><h2>Creating a Landing Page</h2><p>The first step was to make a landing page where the customer will be sent to leave a review.</p><p>You can create a landing page using either (<a href=\"https://carrd.co/\">Carrd</a>, <a href=\"https://convertkit.com/\">ConvertKit</a>, <a href=\"https://kickofflabs.com/\">KickOffLabs</a>), we used Carrd since they were the easiest and quickest way for us to get set up.</p><figure class=\"image\"><img src=\"https://miro.medium.com/max/700/1*4cNBxkVsZh8XbIy3ea0enQ.png\" alt=\"A pop-up showing the text “Would you recommend us to a friend?” and two buttons, one with the text “Yes” and the other with the text “No”\"></figure><p>Example of Landing Page</p><p>When the user selects the “Yes” button they should be brought to the Google My Business page to leave a review or if the user selects “No” then you should redirect them to a form (<a href=\"https://www.google.co.uk/forms/about/\">Google Forms</a>).</p><p>Having a form setup is an excellent way of filtering out the negative reviews whilst still allowing the business to know what they could improve upon.</p><h2>Directing Customers to Landing Page</h2><p>The next step was to get the customer to the landing page, we did this by creating business cards with QR Codes on them.</p><figure class=\"image\"><img src=\"https://miro.medium.com/max/700/1*XY-L_VTRJfyg5cvdUkw4aQ.png\" alt=\"A picture showing a QR Code and the text “HAPPY WITH ORDER?”\" srcset=\"https://miro.medium.com/max/276/1*XY-L_VTRJfyg5cvdUkw4aQ.png 276w, https://miro.medium.com/max/552/1*XY-L_VTRJfyg5cvdUkw4aQ.png 552w, https://miro.medium.com/max/640/1*XY-L_VTRJfyg5cvdUkw4aQ.png 640w, https://miro.medium.com/max/700/1*XY-L_VTRJfyg5cvdUkw4aQ.png 700w\" sizes=\"100vw\" width=\"700\"></figure><p>Example of Business Card</p><p>For this, you could use <a href=\"https://www.instantprint.co.uk/business-cards\">InstantPrint</a>, <a href=\"https://www.vistaprint.co.uk/business-cards\">VistaPrint</a>, or any other printing company.</p><h2>Selling Our Idea</h2><p>After we had set everything up we spent a few hours each day calling local businesses to schedule meetings. After many, many…many calls we had a small handful of promising candidates to pitch to.</p><p>Once the meetings were scheduled we would meet up with them and explain our Idea through a PowerPoint presentation, some were doubtful of us but changed their tune when we offered a trial period to them.</p><p>We gave them the choice of signing up annually or every 3 months, with the majority signing up for 3 months.</p><h2>Auto Reply to Reviews</h2><p>A way to auto-reply was the last thing we set up after we had sold the business on our Idea. The reason for this is it will boost SEO in the long run.</p><p>Setting auto-replies up can be simple with tools like <a href=\"https://zapier.com/\">Zapier</a> or <a href=\"https://www.integromat.com/en\">Integromat</a>.</p><p>&nbsp;</p><p>I hope this can help you earn some extra cash. If you liked this article, please give it some <strong>claps </strong>and leave a comment if this helped you out.</p><p><strong>Have a good day.</strong></p>", "article_image" : "1641323258906-2589550.jpeg", "user" : { "$oid" : "61d4971b45c4f24b6c575149" }, "likes" : [  ], "likeCount" : 0, "comments" : [  ], "createdAt" : { "$date" : "2022-01-04T19:07:38.908+0000" }, "slug" : "making-dollar700-a-month-as-a-student", "__v" : 0 }
]
